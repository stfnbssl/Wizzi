module
    import 
        as React
        from 'react'
    # Redux
    import 
        @ connect
        $if wzCtx.Build.usePackiAspects
            @ ConnectedProps
        from 'react-redux'
    # Styles
    import 
        @ StyleSheet
        @ css
        from 'aphrodite'
    # Features
    import 
        @ getFilesFromQuery 
        @ fileConversions
        from '../features/file'
    import
        @ withAuth
        @ AuthProps
        from '../features/auth'
    import
        @ withPreferences
        @ PreferencesContextType
        from '../features/preferences'
    import
        @ Annotation
        from '../features/annotations'
    import 
        @ SavedPacki
        @ QueryParams
        @ SaveStatus
        @ SaveHistory
        @ SaveOptions
        $if wzCtx.Build.useExpo
            @ SDKVersion
            @ Device
            @ DeviceLog
            @ Platform
        @ PackiState
        @ PackiFile
        @ PackiFiles
        $if wzCtx.Build.useExpo
            @ PackiDependencies
            @ PackiDependency
        @ PackiDefaults
        from '../features/packi'
    import 
        @ PackiSession
        $if wzCtx.Build.useExpo
            @ PackiLogEvent
        @ PackiListenerSubscription
        $if wzCtx.Build.useExpo
            @ isModulePreloaded
        $if wzCtx.Build.useExpo
            from 'packi-sdk'
        $else
            from '../features/packi'
    # Utils
    import nullthrows from 'nullthrows'    
    import debounce from 'lodash/debounce'    
    import 
        @ isMobile
        from '../utils/detectPlatform'
    # Widgets
    import 
        @ AnimatedLogo 
        from './widgets/AnimatedLogo'
    import 
        @ CollapsibleObject 
        from './widgets/CollapsibleObject'
    # Components
    import AppShell from './shell/AppShell'
    import AppDetails from './AppDetails'    
    import 
        @ EditorViewProps
        from './EditorView/EditorViewProps'
    import LazyLoad from './widgets/LazyLoad'
    $if wzCtx.Build.usePackiAspects
        $include app/packi/imports

    # Defaults
    import 
        @ config
        from '../features/config'
    const 
        {
            @ DEFAULT_DESCRIPTION
            @ DEFAULT_CODE
            $if wzCtx.Build.useExpo
                @ DEFAULT_DEPENDENCIES
        = config
    $*
    import 
        @ DEFAULT_DESCRIPTION
        @ DEFAULT_CODE
        $if wzCtx.Build.useExpo
            @ DEFAULT_DEPENDENCIES
        from '../configs/defaults'
    *$
    
    $if wzCtx.Build.usePackiAspects
        +
        $include app/packi/state_dispacth_props

    :type Params
        :{ 
            :p id
                :optional 
                :string 
            :p username
                :optional 
                :string 
            :p projectName
                :optional 
                :string 
            :p repoName
                :optional 
                :string 
    
    :type Props
        :intersect 
            :ref AuthProps
            :ref PreferencesContextType
            $if wzCtx.Build.usePackiAspects
                :ref PropsFromRedux
            :{ 
                :p Packi
                    :optional 
                    :ref SavedPacki
                :p history
                    :{ 
                        :p push
                            :=> 
                                :void 
                                param props
                                    :{ 
                                        :p pathname
                                            :string 
                                        :p search
                                            :string 
                :p match
                    :{ 
                        :p params
                            :ref Params
                :p location
                    :{ 
                        :p search
                            :string 
                :p query
                    :ref QueryParams
                :p userAgent
                    :string 
                $if wzCtx.Build.useExpo
                    :p isEmbedded
                        :optional 
                        :boolean 
                :p files
                    :ref PackiFiles
                :p defaults
                    :ref PackiDefaults
    
    :type State
        :intersect 
            :ref PackiStateProps
            :{ 
                :p session
                    :ref PackiState
                :p selectedFile
                    :string 
                :p sendCodeOnChangeEnabled
                    :boolean 
                :p autosaveEnabled
                    :boolean 
                :p isSavedOnce
                    :boolean 
                :p saveHistory
                    :ref SaveHistory
                :p saveStatus
                    :ref SaveStatus
                $if wzCtx.Build.useExpo
                    :p connectedDevices
                        :[ 
                            :ref Device
                    :p deviceLogs
                        :[ 
                            :ref DeviceLog
                :p isPreview
                    :boolean 
                $if wzCtx.Build.useExpo
                    :p wasUpgraded
                        :boolean 
                    :p initialSdkVersion
                        :ref SDKVersion
                :p isDownloading
                    :boolean 
                :p devicePreviewShown
                    :boolean 
                $if wzCtx.Build.useExpo
                    :p devicePreviewPlatform
                        :ref Platform
                    :p devicePreviewPlatformOptions
                        :[ 
                            :ref PlatformOption
                :p webPreviewURL
                    :string 
                :p isLocalWebPreview
                    :boolean 
                :p verbose
                    :boolean 
                :p annotations
                    :[ 
                        :ref Annotation
                :p snackagerURL
                    :string 
                $if wzCtx.Build.usePackiAspects
                    $include app/packi/state_def

    class Main
        super React.Component
            :param 
                :ref Props
            :param 
                :ref State
        p _previewRef
            _ React.createRef
                :param 
                    :ref Window
        p edited
            :private 
            :boolean 
            = false
        
        app/ctor()
        app/properties()
        $if wzCtx.Build.usePackiAspects
            app/packi/methods()
        app/methods()
        app/handlers()
        $if wzCtx.Build.usePackiAspects
            app/packi/handlers()

        m render

            if this.props && this.state
                $if false
                    return
                        div
                            < CollapsibleObject
                                @ label "props"
                                @ object {this.props}
                            < CollapsibleObject
                                @ label "state"
                                @ object {this.state}
                $if wzCtx.Build.useExpo
                    const 
                        { 
                            @ isEmbedded
                        = this.props
                const experienceURL = this.state.session.url
                if this.state.isPreview
                    return 
                        < AppDetails 
                            @ name {this.state.session.name}
                            @ description {this.state.session.description}
                            @ experienceURL {experienceURL}
                            @ onOpenEditor {this._handleOpenEditor}
                            @ userAgent {this.props.userAgent}
                            $if wzCtx.Build.useExpo
                                @ onDeviceConnectionAttempt {this._handleDeviceConnectionAttempt}
                $if wzCtx.Build.useExpo
                    let isResolving = false
                    for const name in this.state.session.dependencies
                        const dep = this.state.session.dependencies[name]
                        if !dep.handle && !dep.error && !isResolving && !this.state.session.disabled && !isModulePreloaded(name, this.state.session.sdkVersion)
                            set isResolving = true
                return 
                    < LazyLoad 
                        :ref React.ComponentType
                            :param 
                                :ref EditorViewProps
                        @ load
                            => 
                                ( 
                                    $if wzCtx.Build.useExpo
                                        iif isEmbedded
                                            then
                                                _ import
                                                    @ './EditorView/EmbeddedEditorView'
                                            else
                                                _ import
                                                    @ './EditorView/EditorView'
                                    $else
                                        _ import
                                            @ './EditorView/EditorView'
                        { 
                            => 
                                { 
                                    @ loaded
                                    @ data Comp
                                iif loaded && Comp
                                    then
                                        < Comp 
                                            @ annotations {this.state.annotations}
                                            @ autosaveEnabled {this.state.autosaveEnabled}
                                            $if wzCtx.Build.useExpo
                                                @ connectedDevices {this.state.connectedDevices}
                                            @ createdAt
                                                iif this.props.Packi
                                                    then this.props.Packi.created
                                                    else undefined
                                            $if wzCtx.Build.useExpo
                                                @ dependencies {this.state.session.dependencies}
                                                @ missingDependencies {this.state.session.missingDependencies}
                                            @ description {this.state.session.description}
                                            $if wzCtx.Build.useExpo
                                                @ deviceId {this.state.session.deviceId}
                                                @ deviceLogs {this.state.deviceLogs}
                                            @ experienceURL {experienceURL}
                                            $if wzCtx.Build.useExpo
                                                @ experienceName {this.state.session.onlineName ?? this.state.session.name}
                                            @ files {this.state.session.files}
                                            @ isDownloading {this.state.isDownloading}
                                            $if wzCtx.Build.useExpo
                                                @ isLocalWebPreview {this.state.isLocalWebPreview}
                                                @ isResolving {isResolving}
                                            @ name {this.state.session.name}
                                            @ id {this.state.session.id}
                                            $if wzCtx.Build.useExpo
                                                @ onChangeSDKVersion {this._handleChangeSDKVersion}
                                                @ onClearDeviceLogs {this._handleClearDeviceLogs}
                                                @ onDeviceConnectionAttempt {this._handleDeviceConnectionAttempt}
                                            @ onDownloadAsync {this._handleDownloadAsync}
                                            @ onPublishAsync {this._saveAsync}
                                            $if wzCtx.Build.useExpo
                                                @ onReloadSnack {this._reloadSnack}
                                            @ onSendCode {this._handleSendCode}
                                            @ onSubmitMetadata {this._handleSubmitMetadata}
                                            @ onToggleSendCode {this._handleToggleSendCode}
                                            @ onTogglePreview {this._handleTogglePreview}
                                            $if wzCtx.Build.useExpo
                                                @ onChangePlatform {this._handleChangePreviewPlatform}
                                            @ onSelectFile {this._handleSelectFile}
                                            $if wzCtx.Build.useExpo
                                                @ platform {this.state.devicePreviewPlatform}
                                                @ platformOptions {this.state.devicePreviewPlatformOptions}
                                            @ previewRef {this._previewRef}
                                            @ previewShown {this.state.devicePreviewShown}
                                            @ previewURL {this.state.webPreviewURL}
                                            $if wzCtx.Build.useExpo
                                                @ payerCode {this.props.query.appetizePayerCode}
                                            @ saveHistory {this.state.saveHistory}
                                            @ saveStatus {this.state.saveStatus}
                                            $if wzCtx.Build.useExpo
                                                @ sdkVersion {this.state.session.sdkVersion}
                                            @ selectedFile {this.state.selectedFile}
                                            @ sendCodeOnChangeEnabled {this.state.sendCodeOnChangeEnabled}
                                            $if wzCtx.Build.useExpo
                                                @ setDeviceId {this._setDeviceId}
                                            @ snackagerURL {this.state.snackagerURL}
                                            $if wzCtx.Build.useExpo
                                                @ updateDependencies {this._updateDependencies}
                                            @ updateFiles {this._updateFiles}
                                            @ uploadFileAsync {this._uploadAssetAsync}
                                            @ userAgent {this.props.userAgent}
                                            @ verbose {this.state.verbose}
                                            $if wzCtx.Build.useExpo
                                                @ wasUpgraded {this.state.wasUpgraded}
                                            $if wzCtx.Build.usePackiAspects
                                                @ params {this.state.params}
                                                @ currentPacki {this.props.currentPacki}
                                                @ generatedArtifact {this.props.generatedArtifact}
                                                $$ VIA @ creatorUsername {this.state.params.username}
                                                @ fileEntries {this.state.fileEntries}
                                                @ entry {this._findFocusedEntry(this.state.fileEntries)}
                                                @ isWizziJobWaiting {this.state.isWizziJobWaiting}
                                                @ jobError {this.state.jobError}
                                                $$ VIA @ onLoggedOn {this._handleLoggedOn}
                                                $$ VIA @ onLoggedOff {this._handleLoggedOff}
                                                @ onChangeCode {this._handleChangeCode}
                                                @ onFileEntriesChange {this._handleFileEntriesChange}
                                                @ onEntrySelected {this._handleEntrySelected}
                                                @ onSelectPacki {this._handleSelectPacki}
                                                @ onCreatePacki {this._handleCreatePacki}
                                                @ onDeletePacki {this._handleDeletePacki}
                                                @ onExecuteWizziJob {this._executeJobNotDebounced}
                                                @ onSaveCode {this._saveCode}
                                    else
                                        $if wzCtx.Build.useExpo
                                            iif isEmbedded
                                                then
                                                    < EmbeddedShell 
                                                else
                                                    < AppShell 
                                                        @ title {this.state.session.name}
                                                        @ previewShown {this.state.devicePreviewShown}
                                        $else
                                            < AppShell 
                                                @ title {this.state.session.name}
                                                @ previewShown {this.state.devicePreviewShown}
            else
                return
                    div
                        + Not ready

    $if wzCtx.Build.usePackiAspects
        const connector = connect(packiMapStateToProps, packiMapDispatchToProps)
        :type PropsFromRedux
            :ref ConnectedProps
                :param 
                    :typeof connector
        const MainContainer
            _ withPreferences
                _ withAuth
                    _ connector(Main)
    $else
        const MainContainer
            _ withPreferences
                _ connect
                    => 
                        param state
                            :any 
                        (
                            { 
                                @ viewer state.viewer
                    (
                        _ withAuth(Main)
        #
            # 
            # Fetch code from a remote source (if provided) before rendering the main app
            # 
    :type AsyncState
        :{ 
            :p isReady
                :boolean 
            :p files
                :ref PackiFiles
            :p error
                :optional 
                :ref Error
    export-default 
        class AsyncApp
            super React.Component
                :param 
                    :ref Props
                :param 
                    :ref AsyncState
            ctor 
                param props
                    :ref Props
                _ super(props)
                try 
                    const files = getFilesFromQuery(props.query, DEFAULT_CODE)
                    const isReady
                        op! 
                            _ Object.values(files).find
                                => 
                                    param file
                                        :any 
                                    +
                                        @expr file.url
                    set this.state =
                        { 
                            @ files
                            @ isReady
                catch e
                    set this.state =
                        { 
                            @ error e
                            @ files DEFAULT_CODE
                            @ isReady true
            m componentDidMount
                if !this.state.isReady
                    _ this.loadFilesAsync(this.state.files)
                else
                    if this.state.error
                        _ alert(this.state.error.message)
            m loadFilesAsync
                async
                :private 
                param files
                    :any 
                const MIN_LOADING_MS = 1500
                    # Minimum amount of time to show the loading indicator for, so it doesn't
                    # just flicker in and out
                const startTime = Date.now()
                const paths = Object.keys(files)
                    # Load all files with external urls
                try 
                    const contents
                        await 
                            _ Promise.all
                                _ Object.values(files).map
                                    async=> 
                                        param file
                                            :any 
                                        param index
                                            :number 
                                        const path = paths[index]
                                        if file.url
                                            try 
                                                const response
                                                    await 
                                                        _ fetch(file.url)
                                                if !response.ok
                                                    throw 
                                                        new Error
                                                            `lit 
                                                                @ response.status
                                                                + &nbsp;-&nbsp;
                                                                @ response.statusText
                                                const code
                                                    await 
                                                        _ response.text()
                                                return code
                                            catch e
                                                throw 
                                                    new Error
                                                        `lit 
                                                            + We were unable to load code for file "
                                                            @ path
                                                            + " (
                                                            @ e.message
                                                            + )
                                        else
                                            if file.contents
                                                return file.contents
                                            else
                                                throw 
                                                    new Error
                                                        `lit 
                                                            + No code specified for file "
                                                            @ path
                                                            + "
                    set files =
                        { 
                            @ ...files
                    _ paths.forEach
                        => 
                            param path
                            param index
                            set files[path] =
                                { 
                                    @ type files[path].type
                                    @ contents contents[index]
                catch e
                    _ alert(e.message)
                    set files =
                        { 
                            @ ...files
                    _ paths.forEach
                        => 
                            param path
                            set files[path] =
                                { 
                                    @ type files[path].type
                                    @ contents ''
                    _ this.setState
                        { 
                            @ isReady true
                            @ files
                    return 
                const duration = Date.now() - startTime
                    # Upon load, show the whole Packi
                _ setTimeout
                    => 
                        _ this.setState
                            { 
                                @ isReady true
                                @ files
                    iif duration < MIN_LOADING_MS
                        then MIN_LOADING_MS - duration
                        else 0
            m render
                if this.state.isReady
                    return 
                        < MainContainer 
                            @ {...this.props}
                            @ files {this.state.files}
                else
                    return 
                        div 
                            @ className {css(styles.container)}
                            div 
                                @ className {css(styles.logo)}
                                < AnimatedLogo 
                            p 
                                @ className {css(styles.loadingText)}
                                + Loading code from external source...

    const styles
        _ StyleSheet.create
            { 
                { container
                    @ flexDirection 'column'
                    @ display 'flex'
                    @ height '100%'
                    @ width '100%'
                    @ alignItems 'center'
                    @ justifyContent 'center'
                { logo
                    @ transform 'scale(0.5)'
                    @ opacity 0.9
                { loadingText
                    @ marginTop 0
                    @ opacity 0.7
                    @ fontSize 18

$*
module
    import 
        as React
        from 'react'
    import 
        @ Dispatch
        from 'redux'
    import 
        @ connect
        from 'react-redux'
    import 
        @ MuiThemeProvider
        from '@material-ui/core/styles'
    import 
        @ storeTypes
        from '../store'
    import 
        @ getEventServiceInstance
        from '../services'
    import 
        @ appTypes
        @ appActions
        from '../features/app'
    import 
        @ authTypes
        from '../features/auth'
    import 
        @ commonTypes
        from '../../common'
    import 
        @ prefTypes
        @ withPreferences
        from '../features/preferences'
    import 
        @ packiTypes
        @ packiDefaults
        @ packiActions
        from '../features/packi'
    import 
        @ wizziTypes
        @ wizziActions
        from '../features/wizzi'
    import 
        @ FileSystemEntry
        @ TextFileEntry
        @ AssetFileEntry
        from '../features/filelist/types'
    import 
        @ packiToEntryArray
        @ entryArrayToPacki
        @ mixPreviousAndGeneratedPackiFilesToEntryArray
        @ entryArrayDiff
        from '../features/packi/convertFileStructure'
    import updateEntry from '../features/filelist/actions/updateEntry'
    import debounce from 'lodash/debounce'
    import EditorView from '../components/Editor/EditorView'
    import THEME from '../styles/muiTheme'
        # TODO: App container specific or app feature ?
    :type Params
        :{ 
            :p id
                :optional 
                :string 
            :p username
                :optional 
                :string 
            :p repoName
                :optional 
                :string 
        # TODO: App container specific or app feature ?
    :interface StateProps
        :p loggedUser
            :optional 
            :ref appTypes.LoggedUser
        :p packiNames
            :optional 
            :[ 
                :string 
        :p currentPacki
            :optional 
            :ref packiTypes.Packi
        :p packiTemplateNames
            :optional 
            :[ 
                :string 
        :p ownedGitRepositories
            :optional 
            :[ 
                :ref commonTypes.GitRepositoryMeta
        :p generatedArtifact
            :optional 
            :ref wizziTypes.GeneratedArtifact
        :p jobGeneratedArtifacts
            :ref packiTypes.PackiFiles
        :p jobError
            :ref wizziTypes.JobError
    :interface DispatchProps
        :p dispatchLoggedOn
            :=> 
                :void 
                param user
                    :ref appTypes.LoggedUser
        :p dispatchLoggedOff
            :=> 
                :void 
        :p dispatchInitPacki
            :=> 
                :void 
                param preferences
                    :ref prefTypes.PreferencesType
        :p dispatchSelectPacki
            :=> 
                :void 
                param packiId
                    :string 
        :p dispatchSavePacki
            :=> 
                :void 
                param packiId
                    :string 
                param filesToSave
                    :ref packiTypes.PackiFiles
                param packiEntryFiles
                    :ref packiTypes.PackiFiles
        :p dispatchCreatePacki
            :=> 
                :void 
                param packiId
                    :string 
                param packiKind
                    :string 
        :p dispatchDeletePacki
            :=> 
                :void 
                param packiId
                    :string 
        :p dispatchGenerateArtifact
            :=> 
                :void 
                param fileName
                    :string 
                param files
                    :ref packiTypes.PackiFiles
        :p dispatchExecuteJob
            :=> 
                :void 
                param files
                    :ref packiTypes.PackiFiles
        :p dispatchSetTimedService
            :=> 
                :void 
                param name
                    :string 
                param onOff
                    :boolean 
                param payload
                    :any 
                    :optional 
                param frequence
                    :number 
                    :optional 
    const mapStateToProps
        => 
            param state
                :ref storeTypes.StoreState
            :return
                :ref StateProps
            (
                { 
                    @ loggedUser state.app.loggedUser
                    @ currentPacki state.packi.currentPacki
                    @ packiNames state.packi.packiNames
                    @ packiTemplateNames state.packi.packiTemplateNames
                    @ ownedGitRepositories state.packi.ownedGitRepositories
                    @ generatedArtifact state.wizzi.generatedArtifact
                    @ jobGeneratedArtifacts state.wizzi.jobGeneratedArtifacts
                    @ jobError state.wizzi.jobError
    const mapDispatchToProps
        => 
            param dispatch
                :ref Dispatch
            :return
                :ref DispatchProps
            (
                { 
                    @ dispatchLoggedOn
                        => 
                            param user
                                :ref appTypes.LoggedUser
                            _ dispatch(appActions.updateLoggedUser(user))
                    @ dispatchLoggedOff
                        => 
                            _ dispatch(appActions.updateLoggedUser(null))
                    @ dispatchInitPacki
                        => 
                            param preferences
                                :ref prefTypes.PreferencesType
                            _ dispatch
                                _ packiActions.initPackiRequest
                                    { 
                                        @ preferences
                    @ dispatchSelectPacki
                        => 
                            param packiId
                                :string 
                            _ dispatch
                                _ packiActions.selectPackiRequest
                                    { 
                                        @ id packiId
                    @ dispatchSavePacki
                        => 
                            param packiId
                                :string 
                            param filesToSave
                                :ref packiTypes.PackiFiles
                            param packiEntryFiles
                                :ref packiTypes.PackiFiles
                            _ dispatch
                                _ packiActions.savePackiRequest
                                    { 
                                        @ id packiId
                                        @ filesToSave
                                        @ packiEntryFiles
                    @ dispatchCreatePacki
                        => 
                            param packiId
                                :string 
                            param packiKind
                                :string 
                            _ dispatch
                                _ packiActions.createPackiRequest
                                    { 
                                        @ id packiId
                                        { options
                                            @ data packiKind
                    @ dispatchDeletePacki
                        => 
                            param packiId
                                :string 
                            _ dispatch
                                _ packiActions.deletePackiRequest
                                    { 
                                        @ id packiId
                    @ dispatchGenerateArtifact
                        => 
                            param filePath
                                :string 
                            param files
                                :ref packiTypes.PackiFiles
                            if filePath.endsWith('.ittf') && !filePath.endsWith('wfjob.ittf')
                                _ dispatch
                                    _ wizziActions.generateArtifactRequest
                                        { 
                                            @ filePath
                                            @ files
                    @ dispatchExecuteJob
                        => 
                            param files
                                :ref packiTypes.PackiFiles
                            _ dispatch
                                _ wizziActions.executeJobRequest
                                    { 
                                        @ files
                    @ dispatchSetTimedService
                        => 
                            param name
                                :string 
                            param onOff
                                :boolean 
                            param payload
                                :any 
                                :optional 
                            param frequence
                                :number 
                                :optional 
                            _ dispatch
                                _ wizziActions.setTimedService
                                    { 
                                        @ serviceName name
                                        @ onOff
                                        @ payload
                                        @ frequence
    :type Props
        :intersect 
            :ref authTypes.AuthProps
            :ref prefTypes.PreferencesContextType
            :ref StateProps
            :ref DispatchProps
            :{ 
                :p history
                    :{ 
                        :p push
                            :=> 
                                :void 
                                param props
                                    :{ 
                                        :p pathname
                                            :string 
                                        :p search
                                            :string 
                    # from router
                    # from router
                :p match
                    :{ 
                        :p params
                            :ref Params
                    # from router
                    # from router
                :p location
                    :{ 
                        :p search
                            :string 
                    # from router
                    # from dom navigatori in index.tsx
                :p userAgent
                    :string 
                    # from dom navigatori in index.tsx
    :type State
        :intersect 
            :ref StateProps
            :{ 
                :p packiStoreId
                    :optional 
                    :string 
                :p packiSessionReady
                    :boolean 
                :p isSavedOnce
                    :boolean 
                :p saveHistory
                    :ref packiTypes.SaveHistory
                :p saveStatus
                    :ref packiTypes.SaveStatus
                :p params
                    :ref Params
                :p fileEntries
                    :[ 
                        :ref FileSystemEntry
                :p isWizziJobWaiting
                    :boolean 
                :p lastJobfileEntries
                    :[ 
                        :ref FileSystemEntry
    class App
        super React.Component
            :param 
                :ref Props
            :param 
                :ref State
        m getDerivedStateFromProps
            static
            param props
                :ref Props
            param state
                :ref State
            if props.currentPacki && props.currentPacki.id !== state.packiStoreId
                const 
                    { 
                        @ files
                    = props.currentPacki
                if files
                    const fileEntries = packiToEntryArray(files)
                    _ console.log("App.getDerivedStateFromProps.Loaded packi", props.currentPacki.id)
                    return 
                        { 
                            @ fileEntries
                            @ packiStoreId props.currentPacki.id
                            @ isWizziJobWaiting
                                iif 
                                    test
                                        op> 
                                            _ fileEntries.filter
                                                => 
                                                    param e
                                                    _ e.item.path.endsWith('.wfjob.ittf')
                                                . length
                                            + 0
                                    then true
                                    else false
                            @ lastJobfileEntries fileEntries
            if props.jobGeneratedArtifacts && props.jobGeneratedArtifacts !== state.jobGeneratedArtifacts
                const notGenerated
                    _ entryArrayToPacki
                        _ state.fileEntries.filter
                            => 
                                param e
                                + !e.item.generated
                _ console.log("App.getDerivedStateFromProps.notGenerated", notGenerated, 'jobGeneratedArtifacts', props.jobGeneratedArtifacts)
                return 
                    { 
                        @ fileEntries mixPreviousAndGeneratedPackiFilesToEntryArray(notGenerated, props.jobGeneratedArtifacts)
                        @ jobGeneratedArtifacts props.jobGeneratedArtifacts
            if props.jobError !== state.jobError
                return 
                    { 
                        @ jobError props.jobError
            return null
        ctor 
            param props
                :ref Props
            _ super(props)
            const params
                :ref Params
                =
                    { 
                        ... 
                            ( 
                                iif !props.match.params.id && props.match.params.username && props.match.params.repoName
                                    then
                                        { 
                                            @ id
                                                `lit 
                                                    + @
                                                    @ props.match.params.username
                                                    + /
                                                    @ props.match.params.repoName
                                                    + 
                                    else null
            set this.state =
                { 
                    @ packiStoreId undefined
                    @ packiSessionReady false
                    @ isSavedOnce false
                        # We don't have any UI for autosave in embed
                        # In addition, enabling autosave in embed will disable autosave in editor when embed dialog is open
                    @ saveHistory
                        iif props.currentPacki && props.currentPacki.history
                            then props.currentPacki.history
                            else []
                    @ saveStatus
                        iif props.currentPacki && props.currentPacki.isDraft
                            then 'saved-draft'
                            else
                                iif params.id
                                    then 'published'
                                    else 'changed'
                    @ fileEntries []
                    @ generatedArtifact undefined
                    @ jobGeneratedArtifacts undefined
                    @ jobError undefined
                    @ isWizziJobWaiting false
                    @ lastJobfileEntries []
                    @ params
        m componentDidMount
            _ this._initializePackiSession()
                # Raven
                # Session worker
                # this.props.dispatchFetchPacki(packiDefaults.DEFAULT_PACKI_NAME);
            _ this.props.dispatchInitPacki(this.props.preferences)
                # this.props.dispatchFetchPacki(packiDefaults.DEFAULT_PACKI_NAME);
            _ getEventServiceInstance().on
                @ 'EXECUTE_JOB'
                => 
                    param payload
                        :any 
        m componentDidUpdate
            param _
                :ref Props
            param prevState
                :ref State
            if this.state.fileEntries === prevState.fileEntries
                return 
            let diff = entryArrayDiff(prevState.fileEntries, this.state.fileEntries)
            let didFilesChange = false
            _ Object.keys(diff).forEach
                => 
                    param k
                    if diff[k].kind === '+' || diff[k].kind === '-'
                        set didFilesChange = true
                    else
                        if 
                            test
                                && 
                                    + diff[k].b
                                    @expr 
                                        ( 
                                            @expr diff[k].b
                                                :as 
                                                    :[] 
                                                        :ref FileSystemEntry
                                                        :literal 'item'
                                        . virtual
                            set didFilesChange = true
            set diff = entryArrayDiff(prevState.fileEntries, this.state.lastJobfileEntries)
            let didIttfFilesChange = false
            _ Object.keys(diff).forEach
                => 
                    param k
                    if k.endsWith('.ittf')
                        set didIttfFilesChange = true
            if didFilesChange
                if prevState.fileEntries.length > 0
                if didIttfFilesChange
                    _ this.setState
                        { 
                            @ isWizziJobWaiting true
        m componentWillUnmount
        p _initializePackiSession
            async=> 
                _ this.setState
                    { 
                        @ packiSessionReady true
                    # lots of inits
        p _handleLoggedOn
            async=> 
                param user
                    :ref appTypes.LoggedUser
                _ this.props.dispatchLoggedOn(user)
                _ this.props.setPreferences
                    { 
                        @ loggedUid user.uid
        p _handleLoggedOff
            async=> 
                _ this.props.dispatchLoggedOff()
                _ this.props.setPreferences
                    { 
                        @ loggedUid undefined
        p _handleSelectPacki
            async=> 
                param packiId
                    :string 
                _ this.props.dispatchSelectPacki(packiId)
        p _handleCreatePacki
            async=> 
                param packiId
                    :string 
                param packiKind
                    :string 
                _ this.props.dispatchCreatePacki(packiId, packiKind)
        p _handleDeletePacki
            async=> 
                param packiId
                    :string 
                _ this.props.dispatchDeletePacki(packiId)
        p _findFocusedEntry
            => 
                param entries
                    :[ 
                        :ref FileSystemEntry
                :return
                    :union 
                        :ref TextFileEntry
                        :ref AssetFileEntry
                        :undefined 
                _ entries.find
                    => 
                        { 
                            @ item
                            @ state
                        @expr item.type === 'file' && state.isFocused === true
                    # @ts-ignore
        p _handleChangeCode
            => 
                param content
                    :string 
                let focusedEntry
                    :ref FileSystemEntry
                _ this.setState
                    => 
                        param state
                            :ref State
                        return 
                            { 
                                @ saveStatus 'changed'
                                @ fileEntries
                                    _ state.fileEntries.map
                                        => 
                                            param entry
                                            if entry.item.type === 'file' && entry.state.isFocused
                                                set focusedEntry = entry
                                                return 
                                                    _ updateEntry
                                                        @ entry
                                                        { 
                                                            { item
                                                                @ content
                                            return entry
                    => 
                        if focusedEntry.item.path.endsWith('.ittf')
                            _ this._generateArtifact()
        p _handleFileEntriesChange
            => 
                param nextFileEntries
                    :[ 
                        :ref FileSystemEntry
                :return
                    :ref Promise
                        :param void
                return 
                    new Promise
                        => 
                            param resolve
                            _ this.setState
                                => 
                                    param state
                                    let fileEntries = nextFileEntries
                                    return 
                                        { 
                                            @ fileEntries
                                @ resolve
        p _handleEntrySelected
            => 
                param entry
                    :ref FileSystemEntry
                _ console.log('containers.App._handleEntrySelected', this.props.preferences.autoGenSingleDoc, entry.item.path)
                if this.props.preferences.autoGenSingleDoc
                    if entry.item.path.endsWith('.ittf') && entry.item.path.indexOf('/t/') < 0
                        _ this.props.dispatchGenerateArtifact
                            @expr entry.item.path
                            _ entryArrayToPacki
                                _ this.state.fileEntries.filter
                                    => 
                                        param e
                                        _ e.item.path.endsWith('.ittf')
        p _generateArtifactNotDebounced
            => 
                const focusedEntry = this._findFocusedEntry(this.state.fileEntries)
                if focusedEntry
                    _ this.props.dispatchGenerateArtifact
                        @expr focusedEntry.item.path
                        _ entryArrayToPacki
                            _ this.state.fileEntries.filter
                                => 
                                    param e
                                    _ e.item.path.endsWith('.ittf')
                        # TODO send only fileEntries of the same schema of focusedEntry + json schema
        p _generateArtifact
            _ debounce(this._generateArtifactNotDebounced, 1000)
        p _executeJobNotDebounced
            => 
                const jobEntries
                    _ this.state.fileEntries.filter
                        => 
                            param e
                            _ e.item.path.endsWith('.wfjob.ittf')
                if jobEntries.length > 0
                    _ this.setState
                        { 
                            @ lastJobfileEntries this.state.fileEntries
                            @ isWizziJobWaiting false
                    _ this.props.dispatchExecuteJob
                        _ entryArrayToPacki(this.state.fileEntries)
                            # 20/4 entryArrayToPacki(this.state.fileEntries.filter(e => e.item.path.endsWith('.ittf')))
        p _executeJob
            _ debounce(this._executeJobNotDebounced, 5000)
        p _saveCodeNotDebounced
            => 
                _ this.props.dispatchSavePacki
                    @expr this.state.packiStoreId
                        :as 
                            :string 
                    _ entryArrayToPacki
                        _ this.state.fileEntries.filter
                            => 
                                param e
                                @expr !e.item.virtual && !e.item.generated
                    _ entryArrayToPacki(this.state.fileEntries)
        p _saveCode
            _ debounce(this._saveCodeNotDebounced, 1000)
        m render
            return 
                < MuiThemeProvider 
                    @ theme {THEME}
                    < EditorView 
                        @ params {this.state.params}
                        @ userAgent {this.props.userAgent}
                        @ loggedUser {this.props.loggedUser}
                        @ currentPacki {this.props.currentPacki}
                        @ generatedArtifact {this.props.generatedArtifact}
                        @ saveHistory {this.state.saveHistory}
                        @ saveStatus {this.state.saveStatus}
                        @ creatorUsername {this.state.params.username}
                        @ fileEntries {this.state.fileEntries}
                        @ entry {this._findFocusedEntry(this.state.fileEntries)}
                        @ isWizziJobWaiting {this.state.isWizziJobWaiting}
                        @ jobError {this.state.jobError}
                        @ onLoggedOn {this._handleLoggedOn}
                        @ onLoggedOff {this._handleLoggedOff}
                        @ onChangeCode {this._handleChangeCode}
                        @ onFileEntriesChange {this._handleFileEntriesChange}
                        @ onEntrySelected {this._handleEntrySelected}
                        @ onSelectPacki {this._handleSelectPacki}
                        @ onCreatePacki {this._handleCreatePacki}
                        @ onDeletePacki {this._handleDeletePacki}
                        @ onExecuteWizziJob {this._executeJobNotDebounced}
                        @ onSaveCode {this._saveCode}
    export-default 
        _ connect
            :param 
                :ref StateProps
            :param 
                :ref DispatchProps
            @ mapStateToProps
            @ mapDispatchToProps
            (
                _ withPreferences(App)
*$
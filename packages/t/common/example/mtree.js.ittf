$group
	$params &opt

    #
    # Example skeleton specific for the 'wizzi-mtree' kernel package
    #

	#
		# Examples: ${opt.name}
		#
	
    var path = require('path')
	var fs = require('fs')
	var stringify = require('json-stringify-safe')
	var wizziUtils = require('wizzi-utils')
    var file = wizziUtils.file
    var mocks = wizziUtils.mocks
    var createStoreFactory = require('wizzi-repo').createStoreFactory
    
    $if opt.folderLevel == 1
        var liner = require('../lib/loader/liner')
        var nodifier = require('../lib/loader/nodifier')
        var includer = require('../lib/loader/includer')
        var mixer = require('../lib/loader/mixer')
        var appender = require('../lib/loader/appender')
        var evaluator = require('../lib/loader/evaluator')
        var MTreeBrick = require('../lib/loader/mTreeBrick').MTreeBrick
        var LoadHistory = require('../lib/loader/loadHistory').LoadHistory
		var MTreeBrickProvider = require('../lib/loader/mTreeBrickProvider')
    $elif opt.folderLevel == 2
        var liner = require('../../lib/loader/liner')
        var nodifier = require('../../lib/loader/nodifier')
        var includer = require('../../lib/loader/includer')
        var mixer = require('../../lib/loader/mixer')
        var appender = require('../../lib/loader/appender')
        var evaluator = require('../../lib/loader/evaluator')
        var MTreeBrick = require('../../lib/loader/mTreeBrick').MTreeBrick
        var LoadHistory = require('../../lib/loader/loadHistory').LoadHistory
        var MTreeBrickProvider = require('../../lib/loader/mTreeBrickProvider')
    $elif opt.folderLevel == 3
		var liner = require('../../../lib/loader/liner')
        var nodifier = require('../../../lib/loader/nodifier')
        var includer = require('../../../lib/loader/includer')
        var mixer = require('../../../lib/loader/mixer')
        var appender = require('../../../lib/loader/appender')
        var evaluator = require('../../../lib/loader/evaluator')
        var MTreeBrick = require('../../../lib/loader/mTreeBrick').MTreeBrick
        var LoadHistory = require('../../../lib/loader/loadHistory').LoadHistory
        var MTreeBrickProvider = require('../../../lib/loader/mTreeBrickProvider')
    $elif opt.folderLevel == 4
		var liner = require('../../../../lib/loader/liner')
        var nodifier = require('../../../lib/loader/nodifier')
        var includer = require('../../../../lib/loader/includer')
        var mixer = require('../../../../lib/loader/mixer')
        var appender = require('../../../../lib/loader/appender')
        var evaluator = require('../../../../lib/loader/evaluator')
        var MTreeBrick = require('../../../../lib/loader/mTreeBrick').MTreeBrick
		var LoadHistory = require('../../../../lib/loader/loadHistory').LoadHistory
        var MTreeBrickProvider = require('../../../../lib/loader/mTreeBrickProvider')

	$hook imports

    function getFSDocumentStore
        param callback
        _ createStoreFactory
            {
                @ kind 'filesystem'
            f_cb( storeFactory )
                return
                    _ storeFactory
                        @ callback
	
	$hook functions

	var ${opt.name}
		function
			param step_callback
			_ heading1
				@ 'EXAMPLE'
			$hook

    set ${opt.name}.__name = '${opt.name}'	
    
    function printLines
        param lines
        log 'lines from liner ----------------------------------- start'
        foreach l in lines
            log 'line', 'indent: ' + l.indent, 'r,c: ' + l.row + ',' + l.col, 
                \b l.name + ' / ' + l.value, 
                \b (l.hasMacro ? 'hasMacro' : ''),
                \b (l.tagSuffix ? 'tagSuffix: ' + l.tagSuffix : '')
        log 'lines from liner ------------------------------------- end'

    function printNodes_deep
        param n
        param indent
        var mTreeModel = n.model || n.mTreeBrick
        log ' ', new Array(indent).join('  '), 'r,c: ' + n.row + ',' + n.col, 
            \b n.name + ' / ' + n.value, 
            \b (n.hasMacro ? 'hasMacro' : ''),
            \b (n.tagSuffix ? 'tagSuffix: ' + n.tagSuffix : ''),
            \b (mTreeModel.$params ? '$params: ' + mTreeModel.$params : ''),
            \b (mTreeModel.sourceKey ? 'sk: ' + mTreeModel.sourceKey : '')
        foreach c in n.children
            _ printNodes_deep
                @ c
                @ indent + 1
    
    function printNodes
        param nodes
        param title
        log '--- nodes ' + (title || '') + ' ------------------------------------------------- start'
        if nodes.length != 1
            log 'Invalid nodes array, must be of length == 1'
        else
            # log 'nodes.mTreeBrick', nodes[0].mTreeBrick
            # log 'nodes[0]', nodes[0]
            var mTreeModel = nodes[0].model || nodes[0].mTreeBrick
            if mTreeModel
                log ' ', 'nodes.uri', mTreeModel.uri
                log ' ', 'nodes.$schema', mTreeModel.$schema
                log ' ', 'nodes.sourceKey', mTreeModel.sourceKey
                if mTreeModel.$params
                    log ' ', 'nodes.$params', mTreeModel.$params
                if mTreeModel.frontMatter
                    log ' ', 'nodes.frontMatter', mTreeModel.frontMatter
            _ printNodes_deep
                @ nodes[0]
                @ 1
        log '--- nodes ' + (title || '') + ' --------------------------------------------------- end'

    function printEvaluatedNodes_deep
        param n
        param indent
        log ' ', new Array(indent).join('  '), 'r,c: ' + n.r + ',' + n.c, 
            \b n.n + ' / ' + n.v, 
            \b 'sk: ' + n.s,
            \b 'u: ' + n.u
        foreach c in n.children
            _ printEvaluatedNodes_deep
                @ c
                @ indent + 1

    function printEvaluatedNodes
        param evaluated
        param title
        log '--- evaluated nodes ' + (title || '') + ' ------------------------------------------------- start'
        if evaluated && evaluated.nodes && evaluated.nodes.length == 1
            if evaluated.frontMatter
                log ' ', 'evaluated.frontMatter', evaluated.frontMatter
            _ printEvaluatedNodes_deep
                @ evaluated.nodes[0]
                @ 1
        else
            log 'Invalid evaluated object', evaluated
        log '--- evaluated nodes ' + (title || '') + ' --------------------------------------------------- end'

	example_prints( ${opt.name} )

	set module.exports = ${opt.name}

	if typeof require != 'undefined' && require.main === module
		_ ${opt.name}
module
    import 
        as React
        from 'react'
    import 
        @ Dispatch
        from 'redux'
    import 
        @ connect
        from 'react-redux'
    import 
        @ MuiThemeProvider
        from '@material-ui/core/styles'
    import 
        @ storeTypes
        from '../store'
    import 
        @ getEventServiceInstance
        from '../services'
    import 
        @ appTypes
        @ appActions
        from '../features/app'
    import 
        @ authTypes
        from '../features/auth'
    import 
        @ commonTypes
        from '../../common'
    import 
        @ prefTypes
        @ withPreferences
        from '../features/preferences'
    import 
        @ packiTypes
        @ packiDefaults
        @ packiActions
        from '../features/packi'
    import 
        @ wizziTypes
        @ wizziActions
        from '../features/wizzi'
    import 
        @ FileSystemEntry
        @ TextFileEntry
        @ AssetFileEntry
        from '../features/filelist/types'
    import 
        @ packiToEntryArray
        @ entryArrayToPacki
        @ mixPreviousAndGeneratedPackiFilesToEntryArray
        @ entryArrayDiff
        from '../features/packi/convertFileStructure'
    import updateEntry from '../features/filelist/actions/updateEntry'
    import debounce from 'lodash/debounce'
    import EditorView from '../components/Editor/EditorView'
    import THEME from '../styles/muiTheme'
    # TODO: App container specific or app feature ?
    :type Params
        :{ 
            :p id
                :optional 
                :string 
            :p username
                :optional 
                :string 
            :p repoName
                :optional 
                :string 
    :interface StateProps
        :p loggedUser
            :optional 
            :ref appTypes.LoggedUser
        :p packiNames
            :optional 
            :[ 
                :string 
        :p currentPacki
            :optional 
            :ref packiTypes.Packi
        :p packiTemplateNames
            :optional 
            :[ 
                :string 
        :p ownedGitRepositories
            :optional 
            :[ 
                :ref commonTypes.GitRepositoryMeta
        :p generatedArtifact
            :optional 
            :ref wizziTypes.GeneratedArtifact
        :p jobGeneratedArtifacts
            :ref packiTypes.PackiFiles
        :p jobError
            :ref wizziTypes.JobError
    :interface DispatchProps
        :p dispatchLoggedOn
            :=> 
                :void 
                param user
                    :ref appTypes.LoggedUser
        :p dispatchLoggedOff
            :=> 
                :void 
        :p dispatchInitPacki
            :=> 
                :void 
                param preferences
                    :ref prefTypes.PreferencesType
        :p dispatchSelectPacki
            :=> 
                :void 
                param packiId
                    :string 
        :p dispatchSavePacki
            :=> 
                :void 
                param packiId
                    :string 
                param filesToSave
                    :ref packiTypes.PackiFiles
                param packiEntryFiles
                    :ref packiTypes.PackiFiles
        :p dispatchCreatePacki
            :=> 
                :void 
                param packiId
                    :string 
                param packiKind
                    :string 
        :p dispatchDeletePacki
            :=> 
                :void 
                param packiId
                    :string 
        :p dispatchGenerateArtifact
            :=> 
                :void 
                param fileName
                    :string 
                param files
                    :ref packiTypes.PackiFiles
        :p dispatchExecuteJob
            :=> 
                :void 
                param files
                    :ref packiTypes.PackiFiles
        :p dispatchSetTimedService
            :=> 
                :void 
                param name
                    :string 
                param onOff
                    :boolean 
                param payload
                    :any 
                    :optional 
                param frequence
                    :number 
                    :optional 
    const mapStateToProps
        => 
            param state
                :ref storeTypes.StoreState
            :return
                :ref StateProps
            (
                { 
                    @ loggedUser state.app.loggedUser
                    @ currentPacki state.packi.currentPacki
                    @ packiNames state.packi.packiNames
                    @ packiTemplateNames state.packi.packiTemplateNames
                    @ ownedGitRepositories state.packi.ownedGitRepositories
                    @ generatedArtifact state.wizzi.generatedArtifact
                    @ jobGeneratedArtifacts state.wizzi.jobGeneratedArtifacts
                    @ jobError state.wizzi.jobError
    const mapDispatchToProps
        => 
            param dispatch
                :ref Dispatch
            :return
                :ref DispatchProps
            (
                { 
                    @ dispatchLoggedOn
                        => 
                            param user
                                :ref appTypes.LoggedUser
                            _ dispatch(appActions.updateLoggedUser(user))
                    @ dispatchLoggedOff
                        => 
                            _ dispatch(appActions.updateLoggedUser(null))
                    @ dispatchInitPacki
                        => 
                            param preferences
                                :ref prefTypes.PreferencesType
                            _ dispatch
                                _ packiActions.initPackiRequest
                                    { 
                                        @ preferences
                    @ dispatchSelectPacki
                        => 
                            param packiId
                                :string 
                            _ dispatch
                                _ packiActions.selectPackiRequest
                                    { 
                                        @ id packiId
                    @ dispatchSavePacki
                        => 
                            param packiId
                                :string 
                            param filesToSave
                                :ref packiTypes.PackiFiles
                            param packiEntryFiles
                                :ref packiTypes.PackiFiles
                            _ dispatch
                                _ packiActions.savePackiRequest
                                    { 
                                        @ id packiId
                                        @ filesToSave
                                        @ packiEntryFiles
                    @ dispatchCreatePacki
                        => 
                            param packiId
                                :string 
                            param packiKind
                                :string 
                            _ dispatch
                                _ packiActions.createPackiRequest
                                    { 
                                        @ id packiId
                                        { options
                                            @ data packiKind
                    @ dispatchDeletePacki
                        => 
                            param packiId
                                :string 
                            _ dispatch
                                _ packiActions.deletePackiRequest
                                    { 
                                        @ id packiId
                    @ dispatchGenerateArtifact
                        => 
                            param filePath
                                :string 
                            param files
                                :ref packiTypes.PackiFiles
                            if filePath.endsWith('.ittf') && !filePath.endsWith('wfjob.ittf')
                                _ dispatch
                                    _ wizziActions.generateArtifactRequest
                                        { 
                                            @ filePath
                                            @ files
                    @ dispatchExecuteJob
                        => 
                            param files
                                :ref packiTypes.PackiFiles
                            _ dispatch
                                _ wizziActions.executeJobRequest
                                    { 
                                        @ files
                    @ dispatchSetTimedService
                        => 
                            param name
                                :string 
                            param onOff
                                :boolean 
                            param payload
                                :any 
                                :optional 
                            param frequence
                                :number 
                                :optional 
                            _ dispatch
                                _ wizziActions.setTimedService
                                    { 
                                        @ serviceName name
                                        @ onOff
                                        @ payload
                                        @ frequence
    :type Props
        :intersect 
            :ref authTypes.AuthProps
            :ref prefTypes.PreferencesContextType
            :ref StateProps
            :ref DispatchProps
            :{ 
                # from router
                :p history
                    :{ 
                        :p push
                            :=> 
                                :void 
                                param props
                                    :{ 
                                        :p pathname
                                            :string 
                                        :p search
                                            :string 
                # from router
                :p match
                    :{ 
                        :p params
                            :ref Params
                # from router
                :p location
                    :{ 
                        :p search
                            :string 
                # from dom navigatori in index.tsx
                :p userAgent
                    :string 
    :type State
        :intersect 
            :ref StateProps
            :{ 
                :p packiStoreId
                    :optional 
                    :string 
                :p packiSessionReady
                    :boolean 
                :p isSavedOnce
                    :boolean 
                :p saveHistory
                    :ref packiTypes.SaveHistory
                :p saveStatus
                    :ref packiTypes.SaveStatus
                :p params
                    :ref Params
                :p fileEntries
                    :[ 
                        :ref FileSystemEntry
                :p isWizziJobWaiting
                    :boolean 
                :p lastJobfileEntries
                    :[ 
                        :ref FileSystemEntry
    class App
        super React.Component
            :param 
                :ref Props
            :param 
                :ref State
        m getDerivedStateFromProps
            static
            param props
                :ref Props
            param state
                :ref State
            if props.currentPacki && props.currentPacki.id !== state.packiStoreId
                const 
                    { 
                        @ files
                    = props.currentPacki
                if files
                    const fileEntries = packiToEntryArray(files)
                    _ console.log("App.getDerivedStateFromProps.Loaded packi", props.currentPacki.id)
                    return 
                        { 
                            @ fileEntries
                            @ packiStoreId props.currentPacki.id
                            @ isWizziJobWaiting
                                iif 
                                    test
                                        op> 
                                            _ fileEntries.filter
                                                => 
                                                    param e
                                                    _ e.item.path.endsWith('.wfjob.ittf')
                                                . length
                                            + 0
                                    then true
                                    else false
                            @ lastJobfileEntries fileEntries
            if props.jobGeneratedArtifacts && props.jobGeneratedArtifacts !== state.jobGeneratedArtifacts
                const notGenerated
                    _ entryArrayToPacki
                        _ state.fileEntries.filter
                            => 
                                param e
                                + !e.item.generated
                _ console.log("App.getDerivedStateFromProps.notGenerated", notGenerated, 'jobGeneratedArtifacts', props.jobGeneratedArtifacts)
                return 
                    { 
                        @ fileEntries mixPreviousAndGeneratedPackiFilesToEntryArray(notGenerated, props.jobGeneratedArtifacts)
                        @ jobGeneratedArtifacts props.jobGeneratedArtifacts
            if props.jobError !== state.jobError
                return 
                    { 
                        @ jobError props.jobError
            return null
        ctor 
            param props
                :ref Props
            _ super(props)
            const params
                :ref Params
                { 
                    iif ...!props.match.params.id && props.match.params.username && props.match.params.repoName
                        then
                            { 
                                @ id
                                    `lit 
                                        + @
                                        @ props.match.params.username
                                        + /
                                        @ props.match.params.repoName
                                        + 
                        else null
            set this.state =
                { 
                    @ packiStoreId undefined
                    @ packiSessionReady false
                    # We don't have any UI for autosave in embed
                    # In addition, enabling autosave in embed will disable autosave in editor when embed dialog is open
                    @ isSavedOnce false
                    @ saveHistory
                        iif props.currentPacki && props.currentPacki.history
                            then props.currentPacki.history
                            else []
                    @ saveStatus
                        iif props.currentPacki && props.currentPacki.isDraft
                            then 'saved-draft'
                            else
                                iif params.id
                                    then 'published'
                                    else 'changed'
                    @ fileEntries []
                    @ generatedArtifact undefined
                    @ jobGeneratedArtifacts undefined
                    @ jobError undefined
                    @ isWizziJobWaiting false
                    @ lastJobfileEntries []
                    @ params
        m componentDidMount
            # Raven
            # Session worker
            _ this._initializePackiSession
            # this.props.dispatchFetchPacki(packiDefaults.DEFAULT_PACKI_NAME);
            _ this.props.dispatchInitPacki(this.props.preferences)
            _ getEventServiceInstance().on
                @ 'EXECUTE_JOB'
                => 
                    param payload
                        :any 
        m componentDidUpdate
            param _
                :ref Props
            param prevState
                :ref State
            if this.state.fileEntries === prevState.fileEntries
                return 
            let diff = entryArrayDiff(prevState.fileEntries, this.state.fileEntries)
            let didFilesChange = false
            _ Object.keys(diff).forEach
                => 
                    param k
                    # console.log('componentDidUpdate.changed', k, diff[k].kind);
                    if diff[k].kind === '+' || diff[k].kind === '-'
                        set didFilesChange = true
                    else
                        if 
                            test
                                && 
                                    + diff[k].b
                                    + 
                                        ( 
                                            @expr diff[k].b
                                                :as 
                                                    :[] 
                                                        :ref FileSystemEntry
                                                        :literal 'item'
                                        . virtual
                            set didFilesChange = true
            set diff = entryArrayDiff(prevState.fileEntries, this.state.lastJobfileEntries)
            let didIttfFilesChange = false
            _ Object.keys(diff).forEach
                => 
                    param k
                    # console.log('componentDidUpdate.changed', k, diff[k].kind);
                    if k.endsWith('.ittf')
                        set didIttfFilesChange = true
            if didFilesChange
                if prevState.fileEntries.length > 0
                if didIttfFilesChange
                    _ this.setState
                        { 
                            @ isWizziJobWaiting true
        m componentWillUnmount
        p _initializePackiSession
            async=> 
                # lots of inits
                _ this.setState
                    { 
                        @ packiSessionReady true
        p _handleLoggedOn
            async=> 
                param user
                    :ref appTypes.LoggedUser
                _ this.props.dispatchLoggedOn(user)
                _ this.props.setPreferences
                    { 
                        @ loggedUid user.uid
        p _handleLoggedOff
            async=> 
                _ this.props.dispatchLoggedOff
                _ this.props.setPreferences
                    { 
                        @ loggedUid undefined
        p _handleSelectPacki
            async=> 
                param packiId
                    :string 
                _ this.props.dispatchSelectPacki(packiId)
        p _handleCreatePacki
            async=> 
                param packiId
                    :string 
                param packiKind
                    :string 
                _ this.props.dispatchCreatePacki(packiId, packiKind)
        p _handleDeletePacki
            async=> 
                param packiId
                    :string 
                _ this.props.dispatchDeletePacki(packiId)
        => _findFocusedEntry
            param entries
                :[ 
                    :ref FileSystemEntry
            :return
                :union 
                    :ref TextFileEntry
                    :ref AssetFileEntry
                    :undefined 
            # @ts-ignore
            _ entries.find
                => 
                    { 
                        @ item
                        @ state
                    + item.type === 'file' && state.isFocused === true
        => _handleChangeCode
            param content
                :string 
            let focusedEntry
                :ref FileSystemEntry
            _ this.setState
                => 
                    param state
                        :ref State
                    return 
                        { 
                            @ saveStatus 'changed'
                            @ fileEntries
                                _ state.fileEntries.map
                                    => 
                                        param entry
                                        if entry.item.type === 'file' && entry.state.isFocused
                                            set focusedEntry = entry
                                            return 
                                                _ updateEntry
                                                    @ entry
                                                    { 
                                                        { item
                                                            @ content
                                        return entry
                => 
                    if focusedEntry.item.path.endsWith('.ittf')
                        _ this._generateArtifact
        => _handleFileEntriesChange
            param nextFileEntries
                :[ 
                    :ref FileSystemEntry
            :return
                :ref Promise
                    :param void
            return 
                new Promise
                    => 
                        param resolve
                        _ this.setState
                            => 
                                param state
                                let fileEntries = nextFileEntries
                                return 
                                    { 
                                        @ fileEntries
                            @ resolve
        => _handleEntrySelected
            param entry
                :ref FileSystemEntry
            _ console.log('containers.App._handleEntrySelected', this.props.preferences.autoGenSingleDoc, entry.item.path)
            if this.props.preferences.autoGenSingleDoc
                if entry.item.path.endsWith('.ittf') && entry.item.path.indexOf('/t/') < 0
                    _ this.props.dispatchGenerateArtifact
                        @ entry.item.path
                        _ entryArrayToPacki
                            _ this.state.fileEntries.filter
                                => 
                                    param e
                                    _ e.item.path.endsWith('.ittf')
        => _generateArtifactNotDebounced
            const focusedEntry = this._findFocusedEntry(this.state.fileEntries)
            if focusedEntry
                _ this.props.dispatchGenerateArtifact
                    @ focusedEntry.item.path
                    _ entryArrayToPacki
                        _ this.state.fileEntries.filter
                            => 
                                param e
                                _ e.item.path.endsWith('.ittf')
                    # TODO send only fileEntries of the same schema of focusedEntry + json schema
        p _generateArtifact
            _ debounce(this._generateArtifactNotDebounced, 1000)
        => _executeJobNotDebounced
            const jobEntries
                _ this.state.fileEntries.filter
                    => 
                        param e
                        _ e.item.path.endsWith('.wfjob.ittf')
            if jobEntries.length > 0
                _ this.setState
                    { 
                        @ lastJobfileEntries this.state.fileEntries
                        @ isWizziJobWaiting false
                _ this.props.dispatchExecuteJob
                    # 20/4 entryArrayToPacki(this.state.fileEntries.filter(e => e.item.path.endsWith('.ittf')))
                    _ entryArrayToPacki(this.state.fileEntries)
        p _executeJob
            _ debounce(this._executeJobNotDebounced, 5000)
        => _saveCodeNotDebounced
            _ this.props.dispatchSavePacki
                @ this.state.packiStoreId
                    :as 
                        :string 
                _ entryArrayToPacki
                    _ this.state.fileEntries.filter
                        => 
                            param e
                            + !e.item.virtual && !e.item.generated
                _ entryArrayToPacki(this.state.fileEntries)
        p _saveCode
            _ debounce(this._saveCodeNotDebounced, 1000)
        m render
            return 
                < MuiThemeProvider 
                    @ theme {THEME}
                    < EditorView 
                        @ params {this.state.params}
                        @ userAgent {this.props.userAgent}
                        @ loggedUser {this.props.loggedUser}
                        @ currentPacki {this.props.currentPacki}
                        @ generatedArtifact {this.props.generatedArtifact}
                        @ saveHistory {this.state.saveHistory}
                        @ saveStatus {this.state.saveStatus}
                        @ creatorUsername {this.state.params.username}
                        @ fileEntries {this.state.fileEntries}
                        @ entry {this._findFocusedEntry(this.state.fileEntries)}
                        @ isWizziJobWaiting {this.state.isWizziJobWaiting}
                        @ jobError {this.state.jobError}
                        @ onLoggedOn {this._handleLoggedOn}
                        @ onLoggedOff {this._handleLoggedOff}
                        @ onChangeCode {this._handleChangeCode}
                        @ onFileEntriesChange {this._handleFileEntriesChange}
                        @ onEntrySelected {this._handleEntrySelected}
                        @ onSelectPacki {this._handleSelectPacki}
                        @ onCreatePacki {this._handleCreatePacki}
                        @ onDeletePacki {this._handleDeletePacki}
                        @ onExecuteWizziJob {this._executeJobNotDebounced}
                        @ onSaveCode {this._saveCode}
    export-default 
        _ connect
            :param 
                :ref StateProps
            :param 
                :ref DispatchProps
            @ mapStateToProps
            @ mapDispatchToProps
            (
                _ withPreferences(App)

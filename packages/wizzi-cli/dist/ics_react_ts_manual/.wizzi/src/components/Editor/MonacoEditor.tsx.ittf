module
    import 
        as React
        from 'react'
    import 
        @ StyleSheet
        @ css
        from 'aphrodite'
    import classnames from 'classnames'
    import debounce from 'lodash/debounce'
    # import mapValues from 'lodash/mapValues';
    # import { preloadedModules } from 'snack-sdk';
    # import { initVimMode } from 'monaco-vim';
    import 
        as monaco
        from 'monaco-editor/esm/vs/editor/editor.main'
    import 
        @ SimpleEditorModelResolverService
        from 'monaco-editor/esm/vs/editor/standalone/browser/simpleServices'
    import 
        @ StaticServices
        from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices'
    import 
        @ light
        @ dark
        from './themes/monaco'
    import overrides from './themes/monaco-overrides'
    import 
        @ prefTypes
        @ withThemeName
        from '../../features/preferences'
    import ResizeDetector from '../shared/ResizeDetector'
    import prettierCode from '../../features/filelist/prettierCode'
    import getRelativePath from '../../features/filelist/getRelativePath'
    import getFileLanguage from '../../features/filelist/getFileLanguage'
    # import { SDKVersion } from '../../configs/sdk';
    import 
        @ FileSystemEntry
        from '../../features/filelist/types'
    import 
        @ Annotation
        from './convertErrorToAnnotation'
    #
        # *
        # * Monkeypatch to make 'Find All References' work across multiple files
        # * https://github.com/Microsoft/monaco-editor/issues/779#issuecomment-374258435
        # 
    set SimpleEditorModelResolverService.prototype.findModel =
        function 
            param _
                :any 
            param resource
                :any 
            return 
                _ monaco.editor.getModels().find
                    => 
                        param model
                        set model.uri.toString() === resource.toString()
    # @ts-ignore
    set global.MonacoEnvironment =
        { 
            m getWorker
                param _
                    :string 
                param label
                    :string 
                switch label
                    case 'json'
                        # @ts-ignore
                        return 
                            new Worker
                                @ 'monaco-editor/esm/vs/language/json/json.worker'
                                { 
                                    @ type 'module'
                    case 'typescript'
                    case 'javascript'
                        # @ts-ignore
                        return 
                            new Worker
                                @ 'monaco-editor/esm/vs/language/typescript/ts.worker'
                                { 
                                    @ type 'module'
                    default 
                        # @ts-ignore
                        return 
                            new Worker
                                @ 'monaco-editor/esm/vs/editor/editor.worker'
                                { 
                                    @ type 'module'
    _ monaco.editor.defineTheme('light', light)
    _ monaco.editor.defineTheme('dark', dark)
    #
        # *
        # * Disable typescript's diagnostics for JavaScript files.
        # * This suppresses errors when using Flow syntax.
        # * It's also unnecessary since we use ESLint for error checking.
        # 
    _ monaco.languages.typescript.javascriptDefaults.setDiagnosticsOptions
        { 
            @ noSemanticValidation true
            @ noSyntaxValidation true
    #
        # *
        # * Use prettier to format code.
        # * This will replace the default formatter.
        # 
    const documentFormattingProvider
        :ref monaco.languages.DocumentFormattingEditProvider
        { 
            m provideDocumentFormattingEdits
                async
                param model
                const text
                    await 
                        _ prettierCode(model.uri.path, model.getValue)
                return 
                    [ 
                        { 
                            @ range model.getFullModelRange()
                            @ text
    _ monaco.languages.registerDocumentFormattingEditProvider('javascript', documentFormattingProvider)
    _ monaco.languages.registerDocumentFormattingEditProvider('typescript', documentFormattingProvider)
    _ monaco.languages.registerDocumentFormattingEditProvider('markdown', documentFormattingProvider)
    #
        # *
        # * Sync all the models to the worker eagerly.
        # * This enables intelliSense for all files without needing an `addExtraLib` call.
        # 
    _ monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true)
    _ monaco.languages.typescript.javascriptDefaults.setEagerModelSync(true)
    #
        # *
        # * Configure the typescript compiler to detect JSX and load type definitions
        # 
    const compilerOptions
        :ref monaco.languages.typescript.CompilerOptions
        { 
            @ allowJs true
            @ allowSyntheticDefaultImports true
            @ alwaysStrict true
            @ esModuleInterop true
            @ forceConsistentCasingInFileNames true
            @ isolatedModules true
            @ jsx monaco.languages.typescript.JsxEmit.React
            @ module monaco.languages.typescript.ModuleKind.ESNext
            @ moduleResolution monaco.languages.typescript.ModuleResolutionKind.NodeJs
            @ noEmit true
            @ resolveJsonModule true
            @ strict true
            @ target monaco.languages.typescript.ScriptTarget.ESNext
            { paths
                [ '*'
                    @ '*'
                    @ '*.native'
                    @ '*.ios'
                    @ '*.android'
    _ monaco.languages.typescript.typescriptDefaults.setCompilerOptions(compilerOptions)
    _ monaco.languages.typescript.javascriptDefaults.setCompilerOptions(compilerOptions)
    :type DependencyList
        :{ 
            :index 
                :{ 
                    :p version
                        :string 
                param key
                    :string 
    # type EditorMode = 'normal' | 'vim';
    :type Props
        :{ 
            :p entries
                :[ 
                    :ref FileSystemEntry
            :p dependencies
                :{ 
                    :index 
                        :{ 
                            :p version
                                :string 
                        param name
                            :string 
            # sdkVersion: SDKVersion;
            :p path
                :string 
            :p value
                :string 
            # mode: EditorMode;
            :p onOpenPath
                :=> 
                    :void 
                    param path
                        :string 
            :p onValueChange
                :=> 
                    :void 
                    param value
                        :string 
            :p annotations
                :[ 
                    :ref Annotation
            :p lineNumbers
                :optional 
                :union 
                    :literal 'on'
                    :literal 'off'
                    :literal 'relative'
                    :literal 'interval'
            :p wordWrap
                :optional 
                :union 
                    :literal 'off'
                    :literal 'on'
                    :literal 'wordWrapColumn'
                    :literal 'bounded'
            :p scrollBeyondLastLine
                :optional 
                :boolean 
            :p minimap
                :optional 
                :{ 
                    :p enabled
                        :optional 
                        :boolean 
                    :p maxColumn
                        :optional 
                        :number 
                    :p renderCharacters
                        :optional 
                        :boolean 
                    :p showSlider
                        :optional 
                        :union 
                            :literal 'always'
                            :literal 'mouseover'
                    :p side
                        :optional 
                        :union 
                            :literal 'right'
                            :literal 'left'
            :p autoFocus
                :optional 
                :boolean 
            :p fontFamily
                :optional 
                :string 
            :p fontLigatures
                :optional 
                :boolean 
            :p theme
                :ref prefTypes.ThemeName
    # Store editor states such as cursor position, selection and scroll position for each model
    const editorStates = new Map()
    # Store details about typings we have requested and loaded
    const requestedTypings = new Map()
    const extraLibs = new Map()
    const codeEditorService = StaticServices.codeEditorService.get()
    const findModel
        => 
            param path
                :string 
            _ monaco.editor.getModels().find
                => 
                    param model
                    === 
                        + model.uri.path
                        `lit 
                            + /
                            @ path
                            + 
    class MonacoEditor
        super React.Component
            :param 
                :ref Props
        p defaultProps
            static
            :ref Partial
                :param 
                    :ref Props
            { 
                @ lineNumbers 'on'
                @ wordWrap 'on'
                @ scrollBeyondLastLine false
                { minimap
                    @ enabled false
                @ fontFamily 'var(--font-monospace)'
                @ fontLigatures true
        m removePath
            static
            param path
                :string 
            # Remove editor states
            _ editorStates.delete(path)
            # Remove associated models
            const model = findModel(path)
            set model && model.dispose()
        m renamePath
            static
            param oldPath
                :string 
            param newPath
                :string 
            const selection = editorStates.get(oldPath)
            _ editorStates.delete(oldPath)
            _ editorStates.set(newPath, selection)
            _ this.removePath(oldPath)
        m componentDidMount
            # Spawn a worker to fetch type definitions for dependencies
            # @ts-ignore
            #
                # 
                # this._typingsWorker = new Worker('../../workers/typings.worker', { type: 'module' });
                # this._typingsWorker &&
                # this._typingsWorker.addEventListener('message', ({ data }: any) => this._addTypings(data));
                # 
            const 
                { 
                    @ path
                    @ value
                    @ annotations
                    @ autoFocus
                    ... rest
                = this.props
            # The methods provided by the service are on it's prototype
            # So spreading this object doesn't work, we must mutate it
            set codeEditorService.openCodeEditor =
                async=> 
                    { 
                        @ resource
                        @ options
                        :any 
                    param editor
                        :ref monaco.editor.IStandaloneCodeEditor
                    # Remove the leading slash added by the Uri
                    await 
                        _ this.props.onOpenPath(resource.path.replace(/^\//, ''))
                    _ editor.setSelection(options.selection)
                    _ editor.revealLine(options.selection.startLineNumber)
                    return 
                        { 
                            @ getControl
                                => 
                                    + editor
            const editor
                _ monaco.editor.create
                    @ this._node.current
                        :as 
                            :ref HTMLDivElement
                    @ rest
                    @ codeEditorService
            set this._subscription =
                _ editor.onDidChangeModelContent
                    => 
                        const model = editor.getModel()
                        if model
                            const value = model.getValue()
                            if value !== this.props.value
                                _ this.props.onValueChange(value)
            set this._editor = editor
            # this._toggleMode(this.props.mode);
            _ this._openFile(path, value, autoFocus)
            _ this._updateMarkers(annotations)
            # this._fetchTypings(this.props.dependencies, this.props.sdkVersion);
            # Load all the files so the editor can provide proper intellisense
            _ this.props.entries.forEach
                => 
                    { 
                        @ item
                    if 
                        test
                            && 
                                + item.type === 'file' && item.path !== path && !item.asset
                                === 
                                    optypeof 
                                        @expr 
                                            ( 
                                                + item
                                                    :as 
                                                        :any 
                                            . content
                                    + 'string'
                        _ this._initializeFile
                            @ item.path
                            @ 
                                ( 
                                    + item
                                        :as 
                                            :any 
                                . content
            # Hover provider to show version for imported modules
            const hoverProvider
                :ref monaco.languages.HoverProvider
                { 
                    @ provideHover
                        => 
                            param model
                                :ref monaco.editor.ITextModel
                            param position
                                :ref monaco.Position
                            :return
                                :any 
                            # Get the current line
                            const line = model.getLineContent(position.lineNumber)
                            const language = getFileLanguage(this.props.path)
                            if !language
                                return 
                            # Tokenize the line
                            const tokens = monaco.editor.tokenize(line, language)[0]
                            for let i = 0, l = tokens.length; i < l; i++
                                const current = tokens[i]
                                const next = tokens[i + 1]
                                const end
                                    iif next
                                        then next.offset
                                        else line.length
                                if (current.type === 'string.js' || current.type === 'string.ts') && position.column > current.offset && position.column < end
                                    # Get the string for the token and strip quotes
                                    const string = line.slice(current.offset + 1, end - 1)
                                    const deps
                                        _ this._getAllDependencies
                                            @ this.props.dependencies
                                            #
                                                # , this.props.sdkVersion
                                    if deps[string]
                                        return 
                                            { 
                                                @ range new monaco.Range(position.lineNumber, current.offset + 1, position.lineNumber, end)
                                                [ contents
                                                    { 
                                                        @ value
                                                            `lit 
                                                                + version "
                                                                @ deps[string].version
                                                                + "
                                            # If the string refers to a dependency show the version
            # Completion provider to provide autocomplete for files and dependencies
            const completionProvider
                :ref monaco.languages.CompletionItemProvider
                { 
                    [ triggerCharacters
                        @ "'"
                        @ '"'
                        @ '.'
                        @ '/'
                    @ provideCompletionItems
                        => 
                            param model
                                :ref monaco.editor.ITextModel
                            param position
                                :ref monaco.Position
                            # Get editor content before the pointer
                            const textUntilPosition
                                _ model.getValueInRange
                                    { 
                                        @ startLineNumber 1
                                        @ startColumn 1
                                        @ endLineNumber position.lineNumber
                                        @ endColumn position.column
                            if 
                                test
                                    # Match `import "`, `from "`, `require("`
                                    _ /(([\s|\n]+(import|from)\s+)|(\brequire\b\s*\())["|'][^'^"]*$/.test(textUntilPosition)
                                if textUntilPosition.endsWith('.') || textUntilPosition.endsWith('/')
                                    # User is trying to import a file
                                    # Get the text after the quotes
                                    const match = textUntilPosition.match(/[^'"]+$/)
                                    const typed
                                        iif match
                                            then match[0]
                                            else ''
                                    # Map '.' to './' and '..' to '../' for better autocomplete
                                    const prefix
                                        iif typed === '.'
                                            then './'
                                            else
                                                iif typed === '..'
                                                    then '../'
                                                    else typed
                                    const suggestions
                                        @expr
                                            _ this.props.entries.filter
                                                => 
                                                    { 
                                                        @ item
                                                    + item.path !== this.props.path && !item.virtual
                                                ._ map
                                                    => 
                                                        { 
                                                            @ item
                                                        :return
                                                            :union 
                                                                :ref monaco.languages.CompletionItem
                                                                :null 
                                                        let file = getRelativePath(this.props.path, item.path)
                                                        if 
                                                            test
                                                                # Only show files that match the prefix typed by user
                                                                && 
                                                                    + file.startsWith(prefix)
                                                                    + file.split('/').length <= prefix.split('/').length
                                                                        # Only show files in the same directory as the prefix
                                                            # Remove typed text from the path so that don't insert it twice
                                                            set file = file.slice(typed.length)
                                                            return 
                                                                { 
                                                                    # Show only the file name for label
                                                                    @ label
                                                                        _ file.split('/').pop()
                                                                            :as 
                                                                                :string 
                                                                    # Don't keep extension for JS files
                                                                    @ insertText
                                                                        iif item.type === 'file'
                                                                            then file.replace(/\.(js|tsx?)$/, '')
                                                                            else file
                                                                    @ kind
                                                                        iif item.type === 'folder'
                                                                            then monaco.languages.CompletionItemKind.Folder
                                                                            else monaco.languages.CompletionItemKind.File
                                                        return null
                                                ._ filter
                                                    @ Boolean
                                            :as 
                                                :[ 
                                                    :ref monaco.languages.CompletionItem
                                    return 
                                        { 
                                            @ suggestions
                                else
                                    const deps
                                        _ this._getAllDependencies
                                            @ this.props.dependencies
                                            #
                                                # , this.props.sdkVersion
                                    return 
                                        { 
                                            # User is trying to import a dependency
                                            @ suggestions
                                                _ Object.keys(deps).map
                                                    => 
                                                        param name
                                                        (
                                                            { 
                                                                @ label name
                                                                @ insertText name
                                                                @ detail deps[name].version
                                                                @ kind monaco.languages.CompletionItemKind.Module
                            return undefined
            set this._hoverProviderJS = monaco.languages.registerHoverProvider('javascript', hoverProvider)
            set this._hoverProviderTS = monaco.languages.registerHoverProvider('typescript', hoverProvider)
            set this._completionProviderJS = monaco.languages.registerCompletionItemProvider('javascript', completionProvider)
            set this._completionProviderTS = monaco.languages.registerCompletionItemProvider('typescript', completionProvider)
        m componentDidUpdate
            param prevProps
                :ref Props
            const 
                { 
                    @ path
                    @ value
                    # mode,
                    @ annotations
                    @ dependencies
                    # sdkVersion,
                    @ autoFocus
                    @ theme
                    ... rest
                = this.props
            if this._editor
                _ this._editor.updateOptions(rest)
                const model = this._editor.getModel()
                if path !== prevProps.path
                    # Save the editor state for the previous file so we can restore it when it's re-opened
                    _ editorStates.set(prevProps.path, this._editor.saveViewState)
                    _ this._openFile(path, value, autoFocus)
                else
                    if model && value !== model.getValue()
                        _ this._editor.executeEdits
                            @ null
                            [ 
                                { 
                                    @ range model.getFullModelRange()
                                    @ text value
                            # @ts-ignore
            if annotations !== prevProps.annotations
                _ this._updateMarkers(annotations)
            if 
                test
                    set dependencies !== prevProps.dependencies
                    #
                        # || sdkVersion !== prevProps.sdkVersion
                _ this._fetchTypings
                    @ dependencies
                    #
                        # , sdkVersion
            #
                # 
                # if (mode !== prevProps.mode) {
                # this._toggleMode(mode);
                # }
                # 
            if theme !== prevProps.theme
                _ monaco.editor.setTheme(theme)
                    # Update the global editor theme
                    # Monaco doesn't have a way to change theme locally
            if this.props.entries !== prevProps.entries
                _ this.props.entries.forEach
                    => 
                        { 
                            @ item
                        if item.type === 'file' && !item.asset && item.path !== path
                            const previous
                                _ prevProps.entries.find
                                    => 
                                        param e
                                        set e.item.path === item.path
                            # @ts-ignore
                            if previous && previous.item.content === item.content
                                return 
                            _ this._initializeFile
                                @ item.path
                                @ 
                                    ( 
                                        + item
                                            :as 
                                                :any 
                                    . content
                    # Update all changed entries for updated intellisense
        m componentWillUnmount
            set this._subscription && this._subscription.dispose()
            set this._editor && this._editor.dispose()
            set this._hoverProviderJS && this._hoverProviderJS.dispose()
            set this._hoverProviderTS && this._hoverProviderTS.dispose()
            set this._completionProviderJS && this._completionProviderJS.dispose()
            set this._completionProviderTS && this._completionProviderTS.dispose()
            set this._typingsWorker && this._typingsWorker.terminate()
        => _initializeFile
            param path
                :string 
            param value
                :string 
            let model = findModel(path)
            if model && !model.isDisposed()
                _ model.pushEditOperations
                    [ 
                    [ 
                        { 
                            @ range model.getFullModelRange()
                            @ text value
                    # If a model exists, we need to update it's value
                    # This is needed because the content for the file might have been modified externally
                    # Use `pushEditOperations` instead of `setValue` or `applyEdits` to preserve undo stack
                    # @ts-ignore
            else
                set model =
                    _ monaco.editor.createModel
                        @ value
                        @ undefined
                        _ monaco.Uri.from
                            { 
                                @ scheme 'file'
                                @ path
                _ model.updateOptions
                    { 
                        @ tabSize 2
                        @ insertSpaces true
        => _openFile
            param path
                :string 
            param value
                :string 
            param focus
                :boolean 
                :optional 
            _ this._initializeFile(path, value)
            const model = findModel(path)
            if this._editor && model
                _ this._editor.setModel(model)
                # Restore the editor state for the file
                const editorState = editorStates.get(path)
                if editorState
                    _ this._editor.restoreViewState(editorState)
                if focus
                    _ this._editor.focus
        => _getAllDependencies
            param dependencies
                :ref DependencyList
            :return
                :ref DependencyList
            (
                { 
                    # @ts-ignore
                    # ...mapValues(preloadedModules.dependencies[sdkVersion], version => ({ version })),
                    @ ...dependencies
        => _fetchTypings
            param dependencies
                :ref DependencyList
            const deps
                _ this._getAllDependencies
                    @ dependencies
                    #
                        # , sdkVersion
            _ Object.keys(deps).forEach
                => 
                    param qualifier
                    const 
                        { 
                            @ version
                        = deps[qualifier]
                    # Parse the qualifier to get the package name
                    # This will handle qualifiers with deep imports
                    const match = /^(?:@([^/?]+)\/)?([^@/?]+)(?:\/([^@]+))?/.exec(qualifier)
                    if !match
                        return 
                    const name
                        op+ 
                            iif match[1]
                                then
                                    `lit 
                                        + @
                                        @ match[1]
                                        + /
                                else ''
                            + match[2]
                    if requestedTypings.get(name) === version
                        return 
                            # Typing already loaded
                    _ requestedTypings.set(name, version)
                    && 
                        + this._typingsWorker
                        _ this._typingsWorker.postMessage
                            { 
                                @ name
                                @ version
        => _addTypings
            { 
                @ typings
                :{ 
                    :p typings
                        :{ 
                            :index 
                                :string 
                                param key
                                    :string 
            _ Object.keys(typings).forEach
                => 
                    param path
                    const extraLib = extraLibs.get(path)
                    if extraLib
                        _ extraLib.js.dispose
                        _ extraLib.ts.dispose
                    const uri
                        _ monaco.Uri.from
                            { 
                                @ scheme 'file'
                                @ path
                            ._ toString
                    const js = monaco.languages.typescript.javascriptDefaults.addExtraLib(typings[path], uri)
                    const ts = monaco.languages.typescript.typescriptDefaults.addExtraLib(typings[path], uri)
                    _ extraLibs.set
                        @ path
                        { 
                            @ js
                            @ ts
        => _updateMarkers
            param annotations
                :[ 
                    :ref Annotation
            # @ts-ignore
            _ monaco.editor.setModelMarkers(this._editor.getModel, null, annotations)
        #
            # 
            # _toggleMode = (mode: EditorMode) => {
            # if (mode === 'vim' && this._editor) {
            # this._vim = initVimMode(this._editor, this._statusbar.current as HTMLDivElement);
            # } else {
            # this._vim && this._vim.dispose();
            # }
            # };
            # 
        p _handleResize
            _ debounce
                => 
                    + this._editor && this._editor.layout()
                @ 50
                { 
                    @ leading true
                    @ trailing true
        p _typingsWorker
            :union 
                :ref Worker
                :undefined 
        p _hoverProviderJS
            :union 
                :ref monaco.IDisposable
                :undefined 
        p _hoverProviderTS
            :union 
                :ref monaco.IDisposable
                :undefined 
        p _completionProviderJS
            :union 
                :ref monaco.IDisposable
                :undefined 
        p _completionProviderTS
            :union 
                :ref monaco.IDisposable
                :undefined 
        p _subscription
            :union 
                :ref monaco.IDisposable
                :undefined 
        p _editor
            :union 
                :ref monaco.editor.IStandaloneCodeEditor
                :null 
            = null
        p _vim
            :any 
        p _node
            _ React.createRef
                :param 
                    :ref HTMLDivElement
        p _statusbar
            _ React.createRef
                :param 
                    :ref HTMLDivElement
        m render
            return 
                div 
                    @ className {css(styles.container)}
                    < style
                        @ type "text/css"
                        @ dangerouslySetInnerHTML
                            { 
                                @ __html overrides
                    < ResizeDetector 
                        @ onResize {this._handleResize}
                        div 
                            @ ref {this._node}
                            @ className
                                _ classnames
                                    _ css(styles.editor)
                                    @ 'snack-monaco-editor'
                                    `lit 
                                        + theme-
                                        @ this.props.theme
                                        + 
                    { 
                        # 
                            # this.props.mode === 'vim' ? (
                            # <div className="snack-monaco-vim-statusbar" ref={this._statusbar} />
                            # ) : null
    export-default withThemeName(MonacoEditor)
    const styles
        _ StyleSheet.create
            { 
                { container
                    @ display 'flex'
                    @ flex 1
                    @ flexDirection 'column'
                    @ minWidth 0
                    @ minHeight 0
                { editor
                    @ height '100%'
                    @ width '100%'

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./express/account/server/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./express/account/server/config/env.js":
/*!**********************************************!*\
  !*** ./express/account/server/config/env.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return create; });\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dotenv */ \"dotenv\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dotenv__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var envalid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! envalid */ \"envalid\");\n/* harmony import */ var envalid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(envalid__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction validateEnv() {\n  dotenv__WEBPACK_IMPORTED_MODULE_0___default.a.config();\n  var checkedEnv = Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"cleanEnv\"])(process.env, {\n    PORT: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"port\"])(),\n    SESSION_SECRET: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    CORS_CLIENT_ORIGIN: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    MONGO_HOST: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    MONGO_USER: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    MONGO_PASSWORD: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    MONGO_PATH: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    GITHUB_CLIENT_ID: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    GITHUB_CLIENT_SECRET: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    GITHUB_CALLBACK_URL: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    GOOGLE_CLIENT_ID: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    GOOGLE_CLIENT_SECRET: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])(),\n    GOOGLE_CALLBACK_URL: Object(envalid__WEBPACK_IMPORTED_MODULE_1__[\"str\"])()\n  });\n  return checkedEnv;\n}\n\nvar config = null;\nfunction create() {\n  if (config == null) {\n    var checkedEnv = validateEnv();\n    config = {\n      port: checkedEnv.PORT,\n      sessionSecret: checkedEnv.SESSION_SECRET,\n      corsClientOrigin: checkedEnv.CORS_CLIENT_ORIGIN,\n      mongoHost: checkedEnv.MONGO_HOST,\n      mongoUser: checkedEnv.MONGO_USER,\n      mongoPassword: checkedEnv.MONGO_PASSWORD,\n      mongoPath: checkedEnv.MONGO_PATH,\n      githubClientId: checkedEnv.GITHUB_CLIENT_ID,\n      githubClientSecret: checkedEnv.GITHUB_CLIENT_SECRET,\n      githubCallbackURL: checkedEnv.GITHUB_CALLBACK_URL,\n      googleClientId: checkedEnv.GOOGLE_CLIENT_ID,\n      googleClientSecret: checkedEnv.GOOGLE_CLIENT_SECRET,\n      googleCallbackURL: checkedEnv.GOOGLE_CALLBACK_URL\n    };\n    Object.keys(config).forEach(function (element) {\n      if (element.indexOf(\"Pass\") < 0 && element.indexOf(\"Secr\") < 0) {\n        console.log('Created config', element, config[element]);\n      }\n    });\n  }\n\n  return config;\n}\n\n//# sourceURL=webpack:///./express/account/server/config/env.js?");

/***/ }),

/***/ "./express/account/server/config/index.js":
/*!************************************************!*\
  !*** ./express/account/server/config/index.js ***!
  \************************************************/
/*! exports provided: config */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"config\", function() { return config; });\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ \"./express/account/server/config/env.js\");\n\nvar config = Object(_env__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n\n//# sourceURL=webpack:///./express/account/server/config/index.js?");

/***/ }),

/***/ "./express/account/server/index.js":
/*!*****************************************!*\
  !*** ./express/account/server/index.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! express */ \"express\");\n/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(express__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var query_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! query-string */ \"./node_modules/query-string/index.js\");\n/* harmony import */ var query_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(query_string__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _middlewares_session__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./middlewares/session */ \"./express/account/server/middlewares/session.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _config_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config/index */ \"./express/account/server/config/index.js\");\n/* harmony import */ var _packi_api__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../packi/api */ \"./express/packi/api.js\");\n/* harmony import */ var _packi_api__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_packi_api__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nconsole.log('Config', JSON.stringify(_config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"], null, 2));\nvar defaultOwner = 'stfnbssl';\nvar app = express__WEBPACK_IMPORTED_MODULE_1___default()();\nObject(_middlewares_session__WEBPACK_IMPORTED_MODULE_3__[\"SessionMiddleware\"])(app);\napp.set('views', path__WEBPACK_IMPORTED_MODULE_0___default.a.join(__dirname, './views'));\napp.set('view engine', 'pug');\napp.get('/', function (req, res) {\n  console.log('route /', 'req.session', req.session);\n  res.render('index', {\n    title: 'Express - account',\n    message: 'Hello there!'\n  });\n});\napp.get('/dashboard', ensureAuthenticated, function (req, res) {\n  res.render('dashboard', {\n    title: 'Express - account - dashboard'\n  });\n});\napp.get('/login', function (req, res) {\n  res.render('login', {\n    title: 'Express - account - login'\n  });\n});\napp.get('/login/github', function (req, res) {\n  res.redirect(\"https://github.com/login/oauth/authorize?client_id=\".concat(_config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].githubClientId));\n});\nvar github_access_token = null;\napp.get('/api/v1/authenticate/github/callback', function (req, res) {\n  var body = {\n    client_id: _config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].githubClientId,\n    client_secret: _config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].githubClientSecret,\n    code: req.query.code\n  };\n  var opts = {\n    headers: {\n      accept: 'application/json'\n    }\n  };\n  axios__WEBPACK_IMPORTED_MODULE_4___default.a.post(\"https://github.com/login/oauth/access_token\", body, opts).then(function (res) {\n    console.log('github/callback:', JSON.stringify(res.data, null, 2));\n    return res.data['access_token'];\n  }).then(function (_token) {\n    console.log('My token:', _token);\n    github_access_token = _token; // res.json({ ok: 1 });\n\n    res.redirect('/profile/github');\n  })[\"catch\"](function (err) {\n    return res.status(500).json({\n      message: err.message\n    });\n  });\n});\napp.get('/profile/github', function (req, res) {\n  axios__WEBPACK_IMPORTED_MODULE_4___default()({\n    method: 'get',\n    url: \"https://api.github.com/user\",\n    headers: {\n      Authorization: 'token ' + github_access_token\n    }\n  }).then(function (response) {\n    // res.json({ userData: response.data });\n    req.session.user = response.data;\n    res.send('<pre><code>' + JSON.stringify({\n      userData: response.data\n    }, null, 2) + '</code></pre>');\n  });\n});\napp.get('/login/google', function (req, res) {\n  var queryParams = query_string__WEBPACK_IMPORTED_MODULE_2__[\"stringify\"]({\n    client_id: _config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].googleClientId,\n    // It must correspond to what we declared earlier in the backend\n    scope: \"email profile\",\n    // This is the user data you have access to, in our case its just the mail.\n    redirect_uri: 'http://localhost:5000/api/v1/authenticate/google/callback',\n    // This is the uri that will be redirected to if the user signs into his google account successfully\n    nonce: \"gartps\",\n    // \n    response_type: \"code\" // This tells Google to append code to the response which will be sent to the backend which exchange the code for a token\n\n  });\n  res.redirect(\"https://accounts.google.com/o/oauth2/v2/auth?\".concat(queryParams));\n});\nvar google_access_token = null;\napp.get('/api/v1/authenticate/google/callback', function (req, res) {\n  var body = {\n    client_id: _config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].googleClientId,\n    client_secret: _config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].googleClientSecret,\n    code: req.query.code,\n    redirect_uri: 'http://localhost:5000/api/v1/authenticate/google/callback',\n    grant_type: 'authorization_code'\n  };\n  var opts = {\n    headers: {\n      accept: 'application/json'\n    }\n  };\n  axios__WEBPACK_IMPORTED_MODULE_4___default.a.post(\"https://oauth2.googleapis.com/token\", body, opts).then(function (res) {\n    console.log('google/callback:', JSON.stringify(res.data, null, 2));\n    return res.data['access_token'];\n  }).then(function (_token) {\n    console.log('My token:', _token);\n    google_access_token = _token; // res.json({ ok: 1 });\n\n    res.redirect('/profile/google');\n  })[\"catch\"](function (err) {\n    return res.status(500).json({\n      message: err.message\n    });\n  });\n});\napp.get('/profile/google', function (req, res) {\n  axios__WEBPACK_IMPORTED_MODULE_4___default()({\n    method: 'get',\n    url: \"https://www.googleapis.com/oauth2/v2/userinfo\",\n    headers: {\n      Authorization: 'Bearer ' + google_access_token\n    }\n  }).then(function (response) {\n    // res.json({ userData: response.data });\n    req.session.user = response.data;\n    res.send('<pre><code>' + JSON.stringify({\n      userData: response.data\n    }, null, 2) + '</code></pre>');\n  });\n});\napp.get('/logoff', function (req, res) {\n  req.session.user = null;\n  res.redirect('/');\n});\n\nfunction ensureAuthenticated(req, res, next) {\n  if (req.session.user) {\n    return next();\n  }\n\n  res.redirect('/login');\n}\n\n_packi_api__WEBPACK_IMPORTED_MODULE_6___default.a.start(defaultOwner, {}, function (err) {\n  if (err) throw err;\n  console.log('Packi api started');\n  app.listen(_config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].port, function () {\n    console.log(\"Example app listening at http://localhost:\".concat(_config_index__WEBPACK_IMPORTED_MODULE_5__[\"config\"].port));\n  });\n});\n\n//# sourceURL=webpack:///./express/account/server/index.js?");

/***/ }),

/***/ "./express/account/server/middlewares/session.js":
/*!*******************************************************!*\
  !*** ./express/account/server/middlewares/session.js ***!
  \*******************************************************/
/*! exports provided: SessionMiddleware */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SessionMiddleware\", function() { return SessionMiddleware; });\n/* harmony import */ var express_session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! express-session */ \"./node_modules/express-session/index.js\");\n/* harmony import */ var express_session__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(express_session__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var connect_mongo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! connect-mongo */ \"./node_modules/connect-mongo/build/main/index.js\");\n/* harmony import */ var connect_mongo__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(connect_mongo__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var mongoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mongoose */ \"mongoose\");\n/* harmony import */ var mongoose__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mongoose__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _config_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/index */ \"./express/account/server/config/index.js\");\n\n\n\n\nvar SessionMiddleware = function SessionMiddleware(app) {\n  console.log('SessionMiddleware', 'init');\n  var cookieOptions = {\n    // serve secure cookies, requires https\n    secure: app.get('env') === 'production' ? true : false,\n    httpOnly: true,\n    // expires in 14 days\n    maxAge: 14 * 24 * 60 * 60 * 1000\n  };\n\n  if (app.get('env') === 'production') {\n    server.set('trust proxy', 1); // trust first proxy\n  }\n\n  console.log('SessionMiddleware.config.sessionSecret', _config_index__WEBPACK_IMPORTED_MODULE_3__[\"config\"].sessionSecret);\n  var sessionOptions = {\n    name: 'express.account.sid',\n    secret: _config_index__WEBPACK_IMPORTED_MODULE_3__[\"config\"].sessionSecret,\n    store: connect_mongo__WEBPACK_IMPORTED_MODULE_1___default.a.create({\n      mongoUrl: 'mongodb://localhost/test',\n      ttl: 14 * 24 * 60 * 60\n    }),\n    cookie: cookieOptions,\n    resave: false,\n    saveUninitialized: false\n  };\n  app.use(express_session__WEBPACK_IMPORTED_MODULE_0___default()(sessionOptions));\n};\n\n//# sourceURL=webpack:///./express/account/server/middlewares/session.js?");

/***/ }),

/***/ "./express/packi/api.js":
/*!******************************!*\
  !*** ./express/packi/api.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const path = __webpack_require__(/*! path */ \"path\");\n\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nconst NodeCache = __webpack_require__(/*! node-cache */ \"node-cache\");\n\nconst wizziProds = __webpack_require__(/*! ../../wizzi/productions */ \"./wizzi/productions.js\");\n\nconst pDependency = __webpack_require__(/*! ../../mongoose/packi/packiDependency */ \"./mongoose/packi/packiDependency.js\");\n\nconst pItem = __webpack_require__(/*! ../../mongoose/packi/packiItem */ \"./mongoose/packi/packiItem.js\");\n\nconst pActivity = __webpack_require__(/*! ../../mongoose/packi/userActivity */ \"./mongoose/packi/userActivity.js\");\n\nconst pUser = __webpack_require__(/*! ../../mongoose/packi/user */ \"./mongoose/packi/user.js\");\n\nconst userApi = __webpack_require__(/*! ./userApi */ \"./express/packi/userApi.js\");\n\nconst apiCache = new NodeCache({\n  stdTTL: 120,\n  checkperiod: 60\n});\nlet PackiDependency;\nlet PackiItem;\nlet UserActivity;\nlet User;\nlet DefaultContext;\n\nfunction merge(a, b) {\n  var ret = {};\n\n  for (var k in a) {\n    ret[k] = a[k];\n  }\n\n  for (var k in b) {\n    ret[k] = b[k];\n  }\n\n  return ret;\n}\n\nlet started = false;\nlet db;\nlet md;\nmodule.exports = md = {\n  start: function (defaultOwner, defaultContext, callback) {\n    mongoose.connect('mongodb://localhost/test', {\n      useNewUrlParser: true,\n      useUnifiedTopology: true\n    });\n\n    if (started) {\n      // already started\n      return callback(null);\n    }\n\n    started = true;\n    mongoose.set('useFindAndModify', false);\n    db = mongoose.connection;\n    db.on('error', console.error.bind(console, 'connection error:'));\n    db.once('open', function () {\n      PackiDependency = pDependency.getPackiDependency();\n      PackiItem = pItem.getPackiItem();\n      UserActivity = pActivity.getUserActivity();\n      User = pUser.getUser();\n      userApi.start(pUser);\n\n      md._getPackiContextItem(defaultOwner, 'wzCtx;wzctx', {}).then(resultItemContext => {\n        DefaultContext = Object.assign({}, defaultContext, resultItemContext);\n        console.log('packi.api.start', 'got PackiContextItem wzCtx;wzctx');\n        callback(null);\n      }).catch(err => {\n        console.log('packi.api.start', 'error getting PackiContextItem wzCtx;wzctx', err);\n        callback(err);\n      });\n    });\n  },\n  getDefaultContext: function () {\n    return DefaultContext;\n  },\n  getByGithubLogin: userApi.getByGithubLogin,\n  saveFromGithubLogin: userApi.saveFromGithubLogin,\n  getPackiList: function (owner) {\n    var query = {\n      owner: owner\n    };\n    console.log('getPackiList', query);\n    return new Promise((resolve, reject) => {\n      PackiItem.find(query, function (err, result) {\n        if (err) return reject(err);\n        console.log('getPackiList.result.length', result.length);\n\n        if (result.length == 0) {\n          User.find(query, function (err, result) {\n            if (err) return reject(err);\n\n            if (result.length == 0) {}\n          });\n          return reject({\n            found: false,\n            message: 'User not found'\n          });\n        } else return resolve(result);\n      });\n    });\n  },\n  getPacki: function (owner, name) {\n    var query = {\n      owner: owner,\n      name: name\n    };\n    var cacheKey = owner + '|' + name;\n    console.log('getPacki', query);\n    return new Promise((resolve, reject) => {\n      let packiValue = apiCache.get(cacheKey);\n      if (packiValue) return resolve(packiValue);\n      PackiItem.find(query, function (err, result) {\n        if (err) return reject(err);\n        console.log('getPacki.result.length', result.length);\n\n        if (result.length == 1) {\n          const item = result[0]; // console.log('getPacki.item', item);\n\n          if (item.wizziSchema && item.wizziSchema.length > 0) {\n            var querydep = {\n              owner: owner,\n              name: item.wizziSchema\n            };\n            console.log('getPackiDependency', querydep);\n            PackiDependency.find(querydep, function (err, result) {\n              if (err) return reject(err);\n              console.log('PackiDependency.result.length', result.length);\n              let dep = {};\n\n              if (result.length == 1) {\n                dep = result[0]; // console.log('PackiDependency.dep', dep);\n\n                packiValue = {\n                  mainIttf: item.mainIttf,\n                  packiFiles: merge(dep.get('packiFiles', {}), item.get('packiFiles', {}))\n                };\n                apiCache.set(cacheKey, packiValue);\n                return resolve(packiValue);\n              } else {\n                packiValue = {\n                  mainIttf: item.mainIttf,\n                  packiFiles: item.packiFiles\n                };\n                apiCache.set(cacheKey, packiValue);\n                return resolve(packiValue);\n              }\n            });\n          } else {\n            packiValue = {\n              mainIttf: item.mainIttf,\n              packiFiles: item.packiFiles\n            };\n            apiCache.set(cacheKey, packiValue);\n            return resolve(packiValue);\n          }\n        } else {\n          return reject({\n            found: false,\n            message: 'Packi not found'\n          });\n        }\n      });\n    });\n  },\n  getPackiContext: function (owner, queryContext, defaultContext) {\n    return new Promise((resolve, reject) => {\n      if (queryContext && queryContext.length > 0) {\n        const contextItems = queryContext.split('|');\n        var j = 0;\n        let resultContext = defaultContext;\n\n        (function next() {\n          var contextItem = contextItems[j++];\n\n          if (!contextItem) {\n            console.log('done getPackiContext', Object.keys(resultContext));\n            return resolve(resultContext);\n          }\n\n          md._getPackiContextItem(owner, contextItem, defaultContext).then(resultItemContext => {\n            resultContext = Object.assign({}, resultContext, resultItemContext);\n            next();\n          }).catch(err => reject(err));\n        })();\n      } else {\n        resolve(defaultContext);\n      }\n    });\n  },\n  _getPackiContextItem: function (owner, queryContext, defaultContext) {\n    return new Promise((resolve, reject) => {\n      if (queryContext && queryContext.length > 0) {\n        const parts = queryContext.split(';');\n        const contextName = parts[0];\n        const contextPackiName = parts[1];\n        const contextTransformation = parts.length > 2 ? parts[2] : null;\n        console.log('packi.api._getPackiContextItem: contextName', contextName, 'contextPackiName', contextPackiName, 'contextTransformation', contextTransformation);\n\n        if (contextTransformation) {\n          md.getPackiTransformation(owner, contextPackiName, defaultContext, contextTransformation).then(result => {\n            console.log('packi.api._getPackiContextItem: typeof result', typeof result.transformResult); // const contextObject = JSON.parse(result.transformResult);\n\n            resolve(Object.assign({}, defaultContext, {\n              [contextName]: result.transformResult\n            }));\n          });\n        } else {\n          md.getPackiGeneration(owner, contextPackiName, defaultContext).then(result => {\n            console.log('packi.api._getPackiContextItem', result.content.length);\n            const contextObject = JSON.parse(result.content);\n            resolve(Object.assign({}, defaultContext, {\n              [contextName]: contextObject\n            }));\n          });\n        }\n      } else {\n        resolve(defaultContext);\n      }\n    });\n  },\n  getPackiGeneration: function (owner, name, context) {\n    return new Promise((resolve, reject) => {\n      md.getPacki(owner, name).then(packiItem => {\n        wizziProds.generateArtifact(packiItem.mainIttf, packiItem.packiFiles, context).then(result => {\n          console.log('getPackiGeneration', name, result.artifactContent.length);\n          console.log('getPackiGeneration', name, result.artifactContent.substring(0, 500) + '...');\n          const response = {\n            content: result.artifactContent,\n            contentLength: result.artifactContent.length,\n            contentType: contentTypeFor(packiItem.mainIttf)\n          };\n          return resolve(response);\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }).catch(err => {\n      console.log('err', err);\n      reject(err);\n    });\n  },\n  getPackiTransformation: function (owner, name, context, transformerName) {\n    return new Promise((resolve, reject) => {\n      md.getPacki(owner, name).then(packiItem => {\n        wizziProds.transformModel(packiItem.mainIttf, packiItem.packiFiles, context, {\n          transformer: transformerName\n        }).then(result => {\n          console.log('getPackiTransformation', Object.keys(result));\n          return resolve(result);\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }).catch(err => {\n      console.log('err', err);\n      reject(err);\n    });\n  },\n  getUserActivity: function (id) {\n    var query = {\n      _id: id\n    };\n    return new Promise((resolve, reject) => {\n      UserActivity.find(query, function (err, result) {\n        if (err) return reject(err);\n        if (result.length == 1) return resolve(result[0]._doc);\n        return reject(result);\n      });\n    });\n  },\n  saveUserActivity: function (id, items) {\n    var query = {\n      _id: id\n    };\n    return new Promise((resolve, reject) => {\n      UserActivity.find(query, function (err, result) {\n        if (err) return reject(err);\n        const saveItem = result.length == 1 ? result[0]._doc : {\n          _id: id,\n          openPackies: [],\n          openFiles: []\n        };\n\n        if (items.openPacki) {\n          saveItem.openPackies.unshift(items.openPacki);\n          if (saveItem.openPackies.length > 10) saveItem.openPackies.splice(10);\n        }\n\n        if (items.openFile) {\n          saveItem.openFiles.unshift(items.openFile);\n          if (saveItem.openFiles.length > 20) saveItem.openFiles.splice(20);\n        }\n\n        UserActivity.findOneAndUpdate(query, saveItem, {\n          upsert: true,\n          new: true\n        }, function (err, doc) {\n          if (err) {\n            console.log('saveUserActivity err', err);\n            return reject(err);\n          }\n\n          return resolve({\n            upserted: true,\n            message: 'useractivity',\n            doc: doc._doc\n          });\n        });\n      });\n    });\n  },\n  getLastPackiActivity: function (userid) {\n    var query = {\n      _id: userid\n    };\n    return new Promise((resolve, reject) => {\n      UserActivity.find(query, function (err, result) {\n        if (err) return reject(err);\n\n        if (result.length == 1) {\n          const activity = result[0]._doc;\n\n          if (activity.openPackies.length > 0) {\n            md.getPackiItem_Object_By_Owner_Name(userid, activity.openPackies[0]).then(packiItem => {\n              resolve({\n                found: true,\n                _id: packiItem._id,\n                owner: packiItem.owner,\n                name: packiItem.name,\n                selectedFile: activity.openFiles[0],\n                packiFiles: packiItem.packiFiles,\n                mainIttf: packiItem.mainIttf,\n                wizziSchema: packiItem.wizziSchema\n              });\n            });\n          } else resolve({\n            found: false\n          });\n        } else resolve({\n          found: false\n        });\n      });\n    });\n  },\n  getPackiItem_Object_By_Owner_Name: function (owner, name) {\n    var query = {\n      owner: owner,\n      name: name\n    };\n    console.log('getPackiItem_Object_By_Owner_Name', query);\n    return new Promise((resolve, reject) => {\n      PackiItem.find(query, function (err, result) {\n        if (err) return reject(err);\n        console.log('getPackiItem_Object_By_Owner_Name.result.length', result.length);\n\n        if (result.length == 1) {\n          const obj = { ...result[0]._doc,\n            packiFiles: JSON.parse(result[0]._doc.packiFiles)\n          };\n          return resolve({ ...obj,\n            _id: obj._id.toString()\n          });\n        }\n\n        return reject({\n          message: \"packi item not found\",\n          query\n        });\n      });\n    });\n  },\n  getPackiItem_Object_By_Id: function (id) {\n    var query = {\n      _id: id\n    };\n    console.log('getPackiItem_Object_By_Id', query);\n    return new Promise((resolve, reject) => {\n      PackiItem.find(query, function (err, result) {\n        if (err) return reject(err);\n        console.log('getPackiItem_Object_By_Id.result.length', result.length);\n        if (result.length == 1) return resolve(result[0]._doc);\n        return reject({\n          message: \"packi item not found\",\n          query\n        });\n      });\n    });\n  },\n  savePacki: function (owner, name, mainIttf, wizziSchema, packiFiles) {\n    return new Promise((resolve, reject) => {\n      const item = {\n        owner,\n        name,\n        mainIttf,\n        wizziSchema,\n        packiFiles\n      };\n      item.userUpdated = true;\n      var cacheKey = owner + '|' + name;\n      var query = {\n        owner: item.owner,\n        name: item.name\n      }; // console.log('savePacki', item);\n\n      PackiItem.findOneAndUpdate(query, item, {\n        upsert: true,\n        new: true\n      }, function (err, doc) {\n        if (err) {\n          console.log('savePacki err', err);\n          return reject(err);\n        }\n\n        apiCache.del(cacheKey);\n        console.log('savePacki success doc', Object.keys(doc), 'doc._doc', doc._doc);\n        return resolve({\n          upserted: true,\n          message: 'packiitem updated',\n          doc: doc._doc\n        });\n      });\n    });\n  }\n};\nconst extContentTypeMap = {\n  '.css': 'text/css',\n  '.gif': 'image/gif',\n  '.html': 'text/html',\n  '.ittf': 'text/plain',\n  '.jpeg': 'image/jpeg',\n  '.jpg': 'image/jpg',\n  '.js': 'text/javascript',\n  '.json': 'application/json',\n  '.png': 'image/png',\n  '.scss': 'text/scss',\n  '.svg': 'image/svg+xml',\n  '.ttf': 'application/x-font-ttf',\n  '.txt': 'text/plain',\n  '.vtt': 'text/vtt',\n  '.woff': 'application/x-font-woff',\n  '.yaml': 'text/yanl',\n  '.yml': 'text/yanl',\n  '.xml': 'text/xml'\n};\n\nfunction ittfSchemaOf(file) {\n  const nameParts = path.basename(file).split('.');\n\n  if (nameParts[nameParts.length - 1] === 'ittf') {\n    return nameParts[nameParts.length - 2];\n  }\n\n  return undefined;\n}\n\nfunction contentTypeFor(file) {\n  const ittfSchema = ittfSchemaOf(file);\n  console.log('contentTypeFor', file, ittfSchema);\n\n  if (ittfSchema) {\n    return extContentTypeMap['.' + ittfSchema];\n  }\n\n  return undefined;\n}\n\n//# sourceURL=webpack:///./express/packi/api.js?");

/***/ }),

/***/ "./express/packi/userApi.js":
/*!**********************************!*\
  !*** ./express/packi/userApi.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let User;\nlet md;\nmodule.exports = md = {\n  start: function (pUser) {\n    User = pUser.getUser();\n  },\n  getByGithubLogin: function (profile) {\n    var query = {\n      email: profile.email\n    };\n    return new Promise((resolve, reject) => {\n      User.find(query, function (err, result) {\n        if (err) return reject(err);\n        if (result.length == 1) return resolve(result[0]._doc);\n        return reject({\n          message: 'user not found'\n        });\n      });\n    });\n  },\n  validateNotUsed: function (chosenUserid, profile) {\n    return new Promise((resolve, reject) => {\n      let query = {\n        userid: chosenUserid\n      };\n      User.find(query, function (err, result) {\n        if (err) return reject(err);\n        if (result.length == 1) return reject({\n          message: 'userid already in use'\n        });\n        let query = {\n          email: profile.email\n        };\n        User.find(query, function (err, result) {\n          if (err) return reject(err);\n          if (result.length == 1) return reject({\n            message: 'email already in use'\n          });\n          resolve({\n            ok: true\n          });\n        });\n      });\n    });\n  },\n  saveFromGithubLogin: function (chosenUserid, profile) {\n    return new Promise((resolve, reject) => {\n      md.validateNotUsed(chosenUserid, profile.email).then(result => {\n        const newUser = new User({\n          userid: chosenUserid,\n          email: profile.email,\n          provider: 'github',\n          name: profile.name,\n          avatar_url: profile.avatar_url,\n          developer_url: profile.html_url,\n          created_at: new Date(),\n          updated_at: new Date()\n        });\n        newUser.save(function (err, doc) {\n          if (err) {\n            console.log('save user error', err);\n            return reject(err);\n          }\n\n          return resolve({\n            created: true,\n            message: 'user created',\n            doc: doc._doc\n          });\n        });\n      }).catch(err => reject(err));\n    });\n  }\n};\n\n//# sourceURL=webpack:///./express/packi/userApi.js?");

/***/ }),

/***/ "./mongoose/packi/packiDependency.js":
/*!*******************************************!*\
  !*** ./mongoose/packi/packiDependency.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nconst packiDependencySchema = new mongoose.Schema({\n  owner: {\n    type: String\n  },\n  name: {\n    type: String\n  },\n  packiFiles: {\n    type: String,\n    get: function (data) {\n      return JSON.parse(data);\n    },\n    set: function (data) {\n      return JSON.stringify(data);\n    }\n  },\n  userUpdated: Boolean\n});\npackiDependencySchema.index({\n  owner: 1,\n  name: 1\n}, {\n  unique: true\n});\nlet PackiDependency = null;\nmodule.exports = {\n  getPackiDependency: function () {\n    if (!PackiDependency) {\n      PackiDependency = mongoose.model('PackiDependency', packiDependencySchema);\n    }\n\n    return PackiDependency;\n  }\n};\n\n//# sourceURL=webpack:///./mongoose/packi/packiDependency.js?");

/***/ }),

/***/ "./mongoose/packi/packiItem.js":
/*!*************************************!*\
  !*** ./mongoose/packi/packiItem.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nconst packiItemSchema = new mongoose.Schema({\n  owner: {\n    type: String\n  },\n  name: {\n    type: String\n  },\n  wizziSchema: {\n    type: String\n  },\n  mainIttf: {\n    type: String\n  },\n  packiFiles: {\n    type: String,\n    get: function (data) {\n      const json = JSON.parse(data);\n      return json;\n    },\n    set: function (data) {\n      return JSON.stringify(data);\n    }\n  },\n  userUpdated: Boolean\n});\npackiItemSchema.index({\n  owner: 1,\n  name: 1\n}, {\n  unique: true\n});\nlet PackiItem = null;\nmodule.exports = {\n  getPackiItem: function () {\n    if (!PackiItem) {\n      PackiItem = mongoose.model('PackiItem', packiItemSchema);\n    }\n\n    return PackiItem;\n  }\n};\n\n//# sourceURL=webpack:///./mongoose/packi/packiItem.js?");

/***/ }),

/***/ "./mongoose/packi/user.js":
/*!********************************!*\
  !*** ./mongoose/packi/user.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nconst userSchema = new mongoose.Schema({\n  userid: {\n    type: String,\n    unique: true\n  },\n  email: {\n    type: String,\n    unique: true\n  },\n  name: String,\n  location: String,\n  avatar_url: String,\n  provider: String,\n  created_at: Date,\n  updated_at: Date\n});\nlet User;\nmodule.exports = {\n  getUser: function () {\n    if (!User) {\n      User = mongoose.model('User', userSchema);\n    }\n\n    return User;\n  }\n};\n\n//# sourceURL=webpack:///./mongoose/packi/user.js?");

/***/ }),

/***/ "./mongoose/packi/userActivity.js":
/*!****************************************!*\
  !*** ./mongoose/packi/userActivity.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\n\nconst userActivitySchema = new mongoose.Schema({\n  _id: {\n    type: String,\n    unique: true\n  },\n  openPackies: {\n    type: Array\n  },\n  openFiles: {\n    type: Array\n  }\n});\nlet UserActivity = null;\nmodule.exports = {\n  getUserActivity: function () {\n    if (!UserActivity) {\n      UserActivity = mongoose.model('UserActivity', userActivitySchema);\n    }\n\n    return UserActivity;\n  }\n};\n\n//# sourceURL=webpack:///./mongoose/packi/userActivity.js?");

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");\n\n//# sourceURL=webpack:///./node_modules/axios/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/http.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/adapters/http.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\n\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\n\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\n\nvar http = __webpack_require__(/*! http */ \"http\");\n\nvar https = __webpack_require__(/*! https */ \"https\");\n\nvar httpFollow = __webpack_require__(/*! follow-redirects */ \"follow-redirects\").http;\n\nvar httpsFollow = __webpack_require__(/*! follow-redirects */ \"follow-redirects\").https;\n\nvar url = __webpack_require__(/*! url */ \"url\");\n\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nvar pkg = __webpack_require__(/*! ./../../package.json */ \"./node_modules/axios/package.json\");\n\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\n\nvar enhanceError = __webpack_require__(/*! ../core/enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\nvar isHttps = /https:?/;\n/**\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} proxy\n * @param {string} location\n */\n\nfunction setProxy(options, proxy, location) {\n  options.hostname = proxy.host;\n  options.host = proxy.host;\n  options.port = proxy.port;\n  options.path = location; // Basic proxy authorization\n\n  if (proxy.auth) {\n    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n    options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n  } // If a proxy is used, any redirects must also pass through the proxy\n\n\n  options.beforeRedirect = function beforeRedirect(redirection) {\n    redirection.headers.host = redirection.host;\n    setProxy(redirection, proxy, redirection.href);\n  };\n}\n/*eslint consistent-return:0*/\n\n\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var resolve = function resolve(value) {\n      resolvePromise(value);\n    };\n\n    var reject = function reject(value) {\n      rejectPromise(value);\n    };\n\n    var data = config.data;\n    var headers = config.headers; // Set User-Agent (required by some servers)\n    // Only set header if it hasn't been set in config\n    // See https://github.com/axios/axios/issues/69\n\n    if (!headers['User-Agent'] && !headers['user-agent']) {\n      headers['User-Agent'] = 'axios/' + pkg.version;\n    }\n\n    if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {// Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(createError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', config));\n      } // Add Content-Length header if data exists\n\n\n      headers['Content-Length'] = data.length;\n    } // HTTP basic authentication\n\n\n    var auth = undefined;\n\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    } // Parse url\n\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || 'http:';\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth) {\n      delete headers.Authorization;\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: {\n        http: config.httpAgent,\n        https: config.httpsAgent\n      },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n\n            if (proxyElement === '*') {\n              return true;\n            }\n\n            if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port,\n            protocol: parsedProxyUrl.protocol\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } // Create the request\n\n\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return; // uncompress the response body transparently if required\n\n      var stream = res; // return the last request in case of redirects\n\n      var lastRequest = res.req || req; // if no content, is HEAD request or decompress disabled we should not decompress\n\n      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {\n        switch (res.headers['content-encoding']) {\n          /*eslint default-case:0*/\n          case 'gzip':\n          case 'compress':\n          case 'deflate':\n            // add the unzipper to the body stream processing pipeline\n            stream = stream.pipe(zlib.createUnzip()); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n        }\n      }\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk); // make sure the content length is not over the maxContentLength if specified\n\n          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {\n            stream.destroy();\n            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config, null, lastRequest));\n          }\n        });\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(enhanceError(err, config, null, lastRequest));\n        });\n        stream.on('end', function handleStreamEnd() {\n          var responseData = Buffer.concat(responseBuffer);\n\n          if (config.responseType !== 'arraybuffer') {\n            responseData = responseData.toString(config.responseEncoding);\n\n            if (!config.responseEncoding || config.responseEncoding === 'utf8') {\n              responseData = utils.stripBOM(responseData);\n            }\n          }\n\n          response.data = responseData;\n          settle(resolve, reject, response);\n        });\n      }\n    }); // Handle errors\n\n    req.on('error', function handleRequestError(err) {\n      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;\n      reject(enhanceError(err, config, null, req));\n    }); // Handle request timeout\n\n    if (config.timeout) {\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(config.timeout, function handleRequestTimeout() {\n        req.abort();\n        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));\n      });\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (req.aborted) return;\n        req.abort();\n        reject(cancel);\n      });\n    } // Send the request\n\n\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(enhanceError(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/http.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\n\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\n\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\n\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\n\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\n\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\n\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest(); // HTTP basic authentication\n\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS\n\n    request.timeout = config.timeout; // Listen for ready state\n\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      } // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n\n\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      } // Prepare the response\n\n\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n      settle(resolve, reject, response); // Clean up request\n\n      request = null;\n    }; // Handle browser request cancellation (as opposed to a manual cancellation)\n\n\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request\n\n      request = null;\n    }; // Handle low level network errors\n\n\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request)); // Clean up request\n\n      request = null;\n    }; // Handle timeout\n\n\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request\n\n      request = null;\n    }; // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n\n\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    } // Add headers to the request\n\n\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    } // Add withCredentials to request if needed\n\n\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    } // Add responseType to request if needed\n\n\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    } // Handle progress if needed\n\n\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    } // Not all browsers support upload events\n\n\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel); // Clean up request\n\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    } // Send the request\n\n\n    request.send(requestData);\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\n\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\n\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\n\n\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance\n\n  utils.extend(instance, Axios.prototype, context); // Copy context to instance\n\n  utils.extend(instance, context);\n  return instance;\n} // Create the default instance to be exported\n\n\nvar axios = createInstance(defaults); // Expose Axios class to allow class inheritance\n\naxios.Axios = Axios; // Factory for creating new instances\n\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n}; // Expose Cancel & CancelToken\n\n\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\"); // Expose all/spread\n\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\"); // Expose isAxiosError\n\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\nmodule.exports = axios; // Allow use of default import syntax in TypeScript\n\nmodule.exports.default = axios;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\n\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\nmodule.exports = Cancel;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/Cancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\n\n\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\n\n\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\n\n\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\n\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\n\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\n\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\n\n\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\n\n\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config); // Set config.method\n\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  } // Hook up interceptors middleware\n\n\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n}; // Provide aliases for supported request methods\n\n\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\nmodule.exports = Axios;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\n\n\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\n\n\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\n\n\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\n\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\n\n\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n\n  return requestedURL;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/buildFullPath.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\n\n\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/createError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\n\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\n\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\n\n\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\n\n\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config); // Ensure headers exist\n\n  config.headers = config.headers || {}; // Transform request data\n\n  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers\n\n  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);\n  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {\n    delete config.headers[method];\n  });\n  var adapter = config.adapter || defaults.adapter;\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config); // Transform response data\n\n    response.data = transformData(response.data, response.headers, config.transformResponse);\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config); // Transform response data\n\n      if (reason && reason.response) {\n        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\n\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n\n  return error;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/enhanceError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\n\n\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);\n  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {\n    return axiosKeys.indexOf(key) === -1;\n  });\n  utils.forEach(otherKeys, mergeDeepProperties);\n  return config;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/mergeConfig.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\n\n\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\n\n\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n  return data;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/http.js\");\n  }\n\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n\n    return data;\n  }],\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) {\n        /* Ignore */\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\nmodule.exports = defaults;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/defaults.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    return fn.apply(thisArg, args);\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n}\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\n\n\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\n\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      var cookie = [];\n      cookie.push(name + '=' + encodeURIComponent(value));\n\n      if (utils.isNumber(expires)) {\n        cookie.push('expires=' + new Date(expires).toGMTString());\n      }\n\n      if (utils.isString(path)) {\n        cookie.push('path=' + path);\n      }\n\n      if (utils.isString(domain)) {\n        cookie.push('domain=' + domain);\n      }\n\n      if (secure === true) {\n        cookie.push('secure');\n      }\n\n      document.cookie = cookie.join('; ');\n    },\n    read: function read(name) {\n      var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n    remove: function remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  };\n}() : // Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\n\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\n\nmodule.exports = function isAxiosError(payload) {\n  return typeof payload === 'object' && payload.isAxiosError === true;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAxiosError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  var msie = /(msie|trident)/i.test(navigator.userAgent);\n  var urlParsingNode = document.createElement('a');\n  var originURL;\n  /**\n  * Parse a URL to discover it's components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n\n  function resolveURL(url) {\n    var href = url;\n\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute('href', href);\n      href = urlParsingNode.href;\n    }\n\n    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n    };\n  }\n\n  originURL = resolveURL(window.location.href);\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n\n  return function isURLSameOrigin(requestURL) {\n    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() : // Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\"); // Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\n\n\nvar ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\n\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) {\n    return parsed;\n  }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n  return parsed;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\n\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n/*global toString:true*/\n// utils is a library of generic helper functions non-specific to axios\n\n\nvar toString = Object.prototype.toString;\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\n\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\n\n\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\n\n\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\n\n\nfunction isFormData(val) {\n  return typeof FormData !== 'undefined' && val instanceof FormData;\n}\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\n\n\nfunction isArrayBufferView(val) {\n  var result;\n\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && val.buffer instanceof ArrayBuffer;\n  }\n\n  return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\n\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\n\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\n\n\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\n\n\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\n\n\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\n\n\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\n\n\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\n\n\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\n\n\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\n\n\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\n\n\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\n\n\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {\n    return false;\n  }\n\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\n\n\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  } // Force an array if not already something iterable\n\n\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\n\n\nfunction merge()\n/* obj1, obj2, obj3, ... */\n{\n  var result = {};\n\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n\n  return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\n\n\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\n\n\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/*! exports provided: name, version, description, main, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, browser, jsdelivr, unpkg, typings, dependencies, bundlesize, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"axios\\\",\\\"version\\\":\\\"0.21.1\\\",\\\"description\\\":\\\"Promise based HTTP client for the browser and node.js\\\",\\\"main\\\":\\\"index.js\\\",\\\"scripts\\\":{\\\"test\\\":\\\"grunt test && bundlesize\\\",\\\"start\\\":\\\"node ./sandbox/server.js\\\",\\\"build\\\":\\\"NODE_ENV=production grunt build\\\",\\\"preversion\\\":\\\"npm test\\\",\\\"version\\\":\\\"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json\\\",\\\"postversion\\\":\\\"git push && git push --tags\\\",\\\"examples\\\":\\\"node ./examples/server.js\\\",\\\"coveralls\\\":\\\"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js\\\",\\\"fix\\\":\\\"eslint --fix lib/**/*.js\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"https://github.com/axios/axios.git\\\"},\\\"keywords\\\":[\\\"xhr\\\",\\\"http\\\",\\\"ajax\\\",\\\"promise\\\",\\\"node\\\"],\\\"author\\\":\\\"Matt Zabriskie\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/axios/axios/issues\\\"},\\\"homepage\\\":\\\"https://github.com/axios/axios\\\",\\\"devDependencies\\\":{\\\"bundlesize\\\":\\\"^0.17.0\\\",\\\"coveralls\\\":\\\"^3.0.0\\\",\\\"es6-promise\\\":\\\"^4.2.4\\\",\\\"grunt\\\":\\\"^1.0.2\\\",\\\"grunt-banner\\\":\\\"^0.6.0\\\",\\\"grunt-cli\\\":\\\"^1.2.0\\\",\\\"grunt-contrib-clean\\\":\\\"^1.1.0\\\",\\\"grunt-contrib-watch\\\":\\\"^1.0.0\\\",\\\"grunt-eslint\\\":\\\"^20.1.0\\\",\\\"grunt-karma\\\":\\\"^2.0.0\\\",\\\"grunt-mocha-test\\\":\\\"^0.13.3\\\",\\\"grunt-ts\\\":\\\"^6.0.0-beta.19\\\",\\\"grunt-webpack\\\":\\\"^1.0.18\\\",\\\"istanbul-instrumenter-loader\\\":\\\"^1.0.0\\\",\\\"jasmine-core\\\":\\\"^2.4.1\\\",\\\"karma\\\":\\\"^1.3.0\\\",\\\"karma-chrome-launcher\\\":\\\"^2.2.0\\\",\\\"karma-coverage\\\":\\\"^1.1.1\\\",\\\"karma-firefox-launcher\\\":\\\"^1.1.0\\\",\\\"karma-jasmine\\\":\\\"^1.1.1\\\",\\\"karma-jasmine-ajax\\\":\\\"^0.1.13\\\",\\\"karma-opera-launcher\\\":\\\"^1.0.0\\\",\\\"karma-safari-launcher\\\":\\\"^1.0.0\\\",\\\"karma-sauce-launcher\\\":\\\"^1.2.0\\\",\\\"karma-sinon\\\":\\\"^1.0.5\\\",\\\"karma-sourcemap-loader\\\":\\\"^0.3.7\\\",\\\"karma-webpack\\\":\\\"^1.7.0\\\",\\\"load-grunt-tasks\\\":\\\"^3.5.2\\\",\\\"minimist\\\":\\\"^1.2.0\\\",\\\"mocha\\\":\\\"^5.2.0\\\",\\\"sinon\\\":\\\"^4.5.0\\\",\\\"typescript\\\":\\\"^2.8.1\\\",\\\"url-search-params\\\":\\\"^0.10.0\\\",\\\"webpack\\\":\\\"^1.13.1\\\",\\\"webpack-dev-server\\\":\\\"^1.14.1\\\"},\\\"browser\\\":{\\\"./lib/adapters/http.js\\\":\\\"./lib/adapters/xhr.js\\\"},\\\"jsdelivr\\\":\\\"dist/axios.min.js\\\",\\\"unpkg\\\":\\\"dist/axios.min.js\\\",\\\"typings\\\":\\\"./index.d.ts\\\",\\\"dependencies\\\":{\\\"follow-redirects\\\":\\\"^1.10.0\\\"},\\\"bundlesize\\\":[{\\\"path\\\":\\\"./dist/axios.min.js\\\",\\\"threshold\\\":\\\"5kB\\\"}]}\");\n\n//# sourceURL=webpack:///./node_modules/axios/package.json?");

/***/ }),

/***/ "./node_modules/connect-mongo/build/main/index.js":
/*!********************************************************!*\
  !*** ./node_modules/connect-mongo/build/main/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nconst MongoStore_1 = __importDefault(__webpack_require__(/*! ./lib/MongoStore */ \"./node_modules/connect-mongo/build/main/lib/MongoStore.js\"));\n\nmodule.exports = MongoStore_1.default;\n\n//# sourceURL=webpack:///./node_modules/connect-mongo/build/main/index.js?");

/***/ }),

/***/ "./node_modules/connect-mongo/build/main/lib/MongoStore.js":
/*!*****************************************************************!*\
  !*** ./node_modules/connect-mongo/build/main/lib/MongoStore.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst console_1 = __webpack_require__(/*! console */ \"console\");\n\nconst util_1 = __importDefault(__webpack_require__(/*! util */ \"util\"));\n\nconst session = __importStar(__webpack_require__(/*! express-session */ \"./node_modules/express-session/index.js\"));\n\nconst mongodb_1 = __webpack_require__(/*! mongodb */ \"mongodb\");\n\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"debug\"));\n\nconst debug = debug_1.default('connect-mongo'); // eslint-disable-next-line @typescript-eslint/no-empty-function\n\nconst noop = () => {};\n\nconst unit = a => a;\n\nfunction defaultSerializeFunction(session) {\n  // Copy each property of the session to a new object\n  const obj = {};\n  let prop;\n\n  for (prop in session) {\n    if (prop === 'cookie') {\n      // Convert the cookie instance to an object, if possible\n      // This gets rid of the duplicate object under session.cookie.data property\n      // @ts-ignore FIXME:\n      obj.cookie = session.cookie.toJSON ? // @ts-ignore FIXME:\n      session.cookie.toJSON() : session.cookie;\n    } else {\n      // @ts-ignore FIXME:\n      obj[prop] = session[prop];\n    }\n  }\n\n  return obj;\n}\n\nfunction computeTransformFunctions(options) {\n  if (options.serialize || options.unserialize) {\n    return {\n      serialize: options.serialize || defaultSerializeFunction,\n      unserialize: options.unserialize || unit\n    };\n  }\n\n  if (options.stringify === false) {\n    return {\n      serialize: defaultSerializeFunction,\n      unserialize: unit\n    };\n  } // Default case\n\n\n  return {\n    serialize: JSON.stringify,\n    unserialize: JSON.parse\n  };\n}\n\nclass MongoStore extends session.Store {\n  constructor({\n    collectionName = 'sessions',\n    ttl = 1209600,\n    mongoOptions = {\n      useUnifiedTopology: true\n    },\n    autoRemove = 'native',\n    autoRemoveInterval = 10,\n    touchAfter = 0,\n    stringify = true,\n    crypto,\n    ...required\n  }) {\n    super();\n    this.crypto = null;\n    debug('create MongoStore instance');\n    const options = {\n      collectionName,\n      ttl,\n      mongoOptions,\n      autoRemove,\n      autoRemoveInterval,\n      touchAfter,\n      stringify,\n      crypto: { ...{\n          secret: false,\n          algorithm: 'aes-256-gcm',\n          hashing: 'sha512',\n          encodeas: 'base64',\n          key_size: 32,\n          iv_size: 16,\n          at_size: 16\n        },\n        ...crypto\n      },\n      ...required\n    }; // Check params\n\n    console_1.assert(options.mongoUrl || options.clientPromise || options.client, 'You must provide either mongoUrl|clientPromise|client in options');\n    console_1.assert(options.createAutoRemoveIdx === null || options.createAutoRemoveIdx === undefined, 'options.createAutoRemoveIdx has been reverted to autoRemove and autoRemoveInterval');\n    console_1.assert(!options.autoRemoveInterval || options.autoRemoveInterval <= 71582,\n    /* (Math.pow(2, 32) - 1) / (1000 * 60) */\n    'autoRemoveInterval is too large. options.autoRemoveInterval is in minutes but not seconds nor mills');\n    this.transformFunctions = computeTransformFunctions(options);\n\n    let _clientP;\n\n    if (options.mongoUrl) {\n      _clientP = mongodb_1.MongoClient.connect(options.mongoUrl, options.mongoOptions);\n    } else if (options.clientPromise) {\n      _clientP = options.clientPromise;\n    } else if (options.client) {\n      _clientP = Promise.resolve(options.client);\n    } else {\n      throw new Error('Cannot init client. Please provide correct options');\n    }\n\n    console_1.assert(!!_clientP, 'Client is null|undefined');\n    this.clientP = _clientP;\n    this.options = options;\n    this.collectionP = _clientP.then(con => con.db(options.dbName)).then(db => db.collection(options.collectionName)).then(collection => {\n      this.setAutoRemove(collection);\n      return collection;\n    });\n\n    if (options.crypto.secret) {\n      this.crypto = __webpack_require__(/*! kruptein */ \"./node_modules/kruptein/index.js\")(options.crypto);\n    }\n  }\n\n  static create(options) {\n    return new MongoStore(options);\n  }\n\n  setAutoRemove(collection) {\n    const removeQuery = () => ({\n      expires: {\n        $lt: new Date()\n      }\n    });\n\n    switch (this.options.autoRemove) {\n      case 'native':\n        debug('Creating MongoDB TTL index');\n        collection.createIndex({\n          expires: 1\n        }, {\n          expireAfterSeconds: 0,\n          ...this.options.writeOperationOptions\n        });\n        break;\n\n      case 'interval':\n        debug('create Timer to remove expired sessions');\n        this.timer = setInterval(() => collection.deleteMany(removeQuery(), { ...this.options.writeOperationOptions,\n          w: 0,\n          j: false\n        }), this.options.autoRemoveInterval * 1000 * 60);\n        this.timer.unref();\n        break;\n\n      case 'disabled':\n      default:\n        break;\n    }\n  }\n\n  computeStorageId(sessionId) {\n    if (this.options.transformId && typeof this.options.transformId === 'function') {\n      return this.options.transformId(sessionId);\n    }\n\n    return sessionId;\n  }\n  /**\n   * promisify and bind the `this.crypto.get` function.\n   * Please check !!this.crypto === true before using this getter!\n   */\n\n\n  get cryptoGet() {\n    if (!this.crypto) {\n      throw new Error('Check this.crypto before calling this.cryptoGet!');\n    }\n\n    return util_1.default.promisify(this.crypto.get).bind(this.crypto);\n  }\n  /**\n   * Decrypt given session data\n   * @param session session data to be decrypt. Mutate the input session.\n   */\n\n\n  async decryptSession(session) {\n    if (this.crypto && session) {\n      const plaintext = await this.cryptoGet(this.options.crypto.secret, session.session).catch(err => {\n        throw new Error(err);\n      }); // @ts-ignore\n\n      session.session = JSON.parse(plaintext);\n    }\n  }\n  /**\n   * Get a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n\n\n  get(sid, callback) {\n    ;\n\n    (async () => {\n      try {\n        debug(`MongoStore#get=${sid}`);\n        const collection = await this.collectionP;\n        const session = await collection.findOne({\n          _id: this.computeStorageId(sid),\n          $or: [{\n            expires: {\n              $exists: false\n            }\n          }, {\n            expires: {\n              $gt: new Date()\n            }\n          }]\n        });\n\n        if (this.crypto && session) {\n          await this.decryptSession(session).catch(err => callback(err));\n        }\n\n        const s = session && this.transformFunctions.unserialize(session.session);\n\n        if (this.options.touchAfter > 0 && (session === null || session === void 0 ? void 0 : session.lastModified)) {\n          s.lastModified = session.lastModified;\n        }\n\n        this.emit('get', sid);\n        callback(null, s);\n      } catch (error) {\n        callback(error);\n      }\n    })();\n  }\n  /**\n   * Upsert a session into the store given a session ID (sid) and session (session) object.\n   * @param sid session ID\n   * @param session session object\n   */\n\n\n  set(sid, session, callback = noop) {\n    ;\n\n    (async () => {\n      var _a;\n\n      try {\n        debug(`MongoStore#set=${sid}`); // Removing the lastModified prop from the session object before update\n        // @ts-ignore\n\n        if (this.options.touchAfter > 0 && (session === null || session === void 0 ? void 0 : session.lastModified)) {\n          // @ts-ignore\n          delete session.lastModified;\n        }\n\n        const s = {\n          _id: this.computeStorageId(sid),\n          session: this.transformFunctions.serialize(session)\n        }; // Expire handling\n\n        if ((_a = session === null || session === void 0 ? void 0 : session.cookie) === null || _a === void 0 ? void 0 : _a.expires) {\n          s.expires = new Date(session.cookie.expires);\n        } else {\n          // If there's no expiration date specified, it is\n          // browser-session cookie or there is no cookie at all,\n          // as per the connect docs.\n          //\n          // So we set the expiration to two-weeks from now\n          // - as is common practice in the industry (e.g Django) -\n          // or the default specified in the options.\n          s.expires = new Date(Date.now() + this.options.ttl * 1000);\n        } // Last modify handling\n\n\n        if (this.options.touchAfter > 0) {\n          s.lastModified = new Date();\n        }\n\n        if (this.crypto) {\n          const cryptoSet = util_1.default.promisify(this.crypto.set).bind(this.crypto);\n\n          try {\n            const data = await cryptoSet(this.options.crypto.secret, s.session).catch(err => {\n              throw new Error(err);\n            });\n            s.session = data;\n          } catch (error) {\n            callback(error);\n          }\n        }\n\n        const collection = await this.collectionP;\n        const rawResp = await collection.updateOne({\n          _id: s._id\n        }, {\n          $set: s\n        }, {\n          upsert: true,\n          ...this.options.writeOperationOptions\n        });\n\n        if (rawResp.upsertedCount > 0) {\n          this.emit('create', sid);\n        } else {\n          this.emit('update', sid);\n        }\n\n        this.emit('set', sid);\n        callback(null);\n      } catch (error) {\n        callback(error);\n      }\n    })();\n  }\n\n  touch(sid, session, callback = noop) {\n    ;\n\n    (async () => {\n      var _a;\n\n      try {\n        debug(`MongoStore#touch=${sid}`);\n        const updateFields = {};\n        const touchAfter = this.options.touchAfter * 1000;\n        const lastModified = session.lastModified ? session.lastModified.getTime() : 0;\n        const currentDate = new Date(); // If the given options has a touchAfter property, check if the\n        // current timestamp - lastModified timestamp is bigger than\n        // the specified, if it's not, don't touch the session\n\n        if (touchAfter > 0 && lastModified > 0) {\n          const timeElapsed = currentDate.getTime() - lastModified;\n\n          if (timeElapsed < touchAfter) {\n            debug(`Skip touching session=${sid}`);\n            return callback(null);\n          }\n\n          updateFields.lastModified = currentDate;\n        }\n\n        if ((_a = session === null || session === void 0 ? void 0 : session.cookie) === null || _a === void 0 ? void 0 : _a.expires) {\n          updateFields.expires = new Date(session.cookie.expires);\n        } else {\n          updateFields.expires = new Date(Date.now() + this.options.ttl * 1000);\n        }\n\n        const collection = await this.collectionP;\n        const rawResp = await collection.updateOne({\n          _id: this.computeStorageId(sid)\n        }, {\n          $set: updateFields\n        }, this.options.writeOperationOptions);\n\n        if (rawResp.matchedCount === 0) {\n          return callback(new Error('Unable to find the session to touch'));\n        } else {\n          this.emit('touch', sid, session);\n          return callback(null);\n        }\n      } catch (error) {\n        return callback(error);\n      }\n    })();\n  }\n  /**\n   * Get all sessions in the store as an array\n   */\n\n\n  all(callback) {\n    ;\n\n    (async () => {\n      try {\n        debug('MongoStore#all()');\n        const collection = await this.collectionP;\n        const sessions = collection.find({\n          $or: [{\n            expires: {\n              $exists: false\n            }\n          }, {\n            expires: {\n              $gt: new Date()\n            }\n          }]\n        });\n        const results = [];\n\n        for await (const session of sessions) {\n          if (this.crypto && session) {\n            await this.decryptSession(session);\n          }\n\n          results.push(this.transformFunctions.unserialize(session.session));\n        }\n\n        this.emit('all', results);\n        callback(null, results);\n      } catch (error) {\n        callback(error);\n      }\n    })();\n  }\n  /**\n   * Destroy/delete a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n\n\n  destroy(sid, callback = noop) {\n    debug(`MongoStore#destroy=${sid}`);\n    this.collectionP.then(colleciton => colleciton.deleteOne({\n      _id: this.computeStorageId(sid)\n    }, this.options.writeOperationOptions)).then(() => {\n      this.emit('destroy', sid);\n      callback(null);\n    }).catch(err => callback(err));\n  }\n  /**\n   * Get the count of all sessions in the store\n   */\n\n\n  length(callback) {\n    debug('MongoStore#length()');\n    this.collectionP.then(collection => collection.countDocuments()).then(c => callback(null, c)) // @ts-ignore\n    .catch(err => callback(err));\n  }\n  /**\n   * Delete all sessions from the store.\n   */\n\n\n  clear(callback = noop) {\n    debug('MongoStore#clear()');\n    this.collectionP.then(collection => collection.drop()).then(() => callback(null)).catch(err => callback(err));\n  }\n  /**\n   * Close database connection\n   */\n\n\n  close() {\n    debug('MongoStore#close()');\n    return this.clientP.then(c => c.close());\n  }\n\n}\n\nexports.default = MongoStore;\n\n//# sourceURL=webpack:///./node_modules/connect-mongo/build/main/lib/MongoStore.js?");

/***/ }),

/***/ "./node_modules/express-session/index.js":
/*!***********************************************!*\
  !*** ./node_modules/express-session/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * express-session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"safe-buffer\").Buffer;\n\nvar cookie = __webpack_require__(/*! cookie */ \"cookie\");\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar debug = __webpack_require__(/*! debug */ \"debug\")('express-session');\n\nvar deprecate = __webpack_require__(/*! depd */ \"depd\")('express-session');\n\nvar onHeaders = __webpack_require__(/*! on-headers */ \"on-headers\");\n\nvar parseUrl = __webpack_require__(/*! parseurl */ \"parseurl\");\n\nvar signature = __webpack_require__(/*! cookie-signature */ \"cookie-signature\");\n\nvar uid = __webpack_require__(/*! uid-safe */ \"./node_modules/uid-safe/index.js\").sync;\n\nvar Cookie = __webpack_require__(/*! ./session/cookie */ \"./node_modules/express-session/session/cookie.js\");\n\nvar MemoryStore = __webpack_require__(/*! ./session/memory */ \"./node_modules/express-session/session/memory.js\");\n\nvar Session = __webpack_require__(/*! ./session/session */ \"./node_modules/express-session/session/session.js\");\n\nvar Store = __webpack_require__(/*! ./session/store */ \"./node_modules/express-session/session/store.js\"); // environment\n\n\nvar env = \"development\";\n/**\n * Expose the middleware.\n */\n\nexports = module.exports = session;\n/**\n * Expose constructors.\n */\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n/**\n * Warning message for `MemoryStore` usage in production.\n * @private\n */\n\nvar warning = 'Warning: connect.session() MemoryStore is not\\n' + 'designed for a production environment, as it will leak\\n' + 'memory, and will not scale past a single process.';\n/**\n * Node.js 0.8+ async implementation.\n * @private\n */\n\n/* istanbul ignore next */\n\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n/**\n * Setup session store with the given `options`.\n *\n * @param {Object} [options]\n * @param {Object} [options.cookie] Options for cookie\n * @param {Function} [options.genid]\n * @param {String} [options.name=connect.sid] Session ID cookie name\n * @param {Boolean} [options.proxy]\n * @param {Boolean} [options.resave] Resave unmodified sessions back to the store\n * @param {Boolean} [options.rolling] Enable/disable rolling session expiration\n * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store\n * @param {String|Array} [options.secret] Secret for signing session ID\n * @param {Object} [options.store=MemoryStore] Session store\n * @param {String} [options.unset]\n * @return {Function} middleware\n * @public\n */\n\nfunction session(options) {\n  var opts = options || {}; // get the cookie options\n\n  var cookieOptions = opts.cookie || {}; // get the session id generate function\n\n  var generateId = opts.genid || generateSessionId; // get the session cookie name\n\n  var name = opts.name || opts.key || 'connect.sid'; // get the session store\n\n  var store = opts.store || new MemoryStore(); // get the trust proxy setting\n\n  var trustProxy = opts.proxy; // get the resave session option\n\n  var resaveSession = opts.resave; // get the rolling session option\n\n  var rollingSessions = Boolean(opts.rolling); // get the save uninitialized session option\n\n  var saveUninitializedSession = opts.saveUninitialized; // get the cookie signing secret\n\n  var secret = opts.secret;\n\n  if (typeof generateId !== 'function') {\n    throw new TypeError('genid option must be a function');\n  }\n\n  if (resaveSession === undefined) {\n    deprecate('undefined resave option; provide resave option');\n    resaveSession = true;\n  }\n\n  if (saveUninitializedSession === undefined) {\n    deprecate('undefined saveUninitialized option; provide saveUninitialized option');\n    saveUninitializedSession = true;\n  }\n\n  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {\n    throw new TypeError('unset option must be \"destroy\" or \"keep\"');\n  } // TODO: switch to \"destroy\" on next major\n\n\n  var unsetDestroy = opts.unset === 'destroy';\n\n  if (Array.isArray(secret) && secret.length === 0) {\n    throw new TypeError('secret option array must contain one or more strings');\n  }\n\n  if (secret && !Array.isArray(secret)) {\n    secret = [secret];\n  }\n\n  if (!secret) {\n    deprecate('req.secret; provide secret option');\n  } // notify user that this store is not\n  // meant for a production environment\n\n  /* istanbul ignore next: not tested */\n\n\n  if (env === 'production' && store instanceof MemoryStore) {\n    console.warn(warning);\n  } // generates the new session\n\n\n  store.generate = function (req) {\n    req.sessionID = generateId(req);\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookieOptions);\n\n    if (cookieOptions.secure === 'auto') {\n      req.session.cookie.secure = issecure(req, trustProxy);\n    }\n  };\n\n  var storeImplementsTouch = typeof store.touch === 'function'; // register event listeners for the store to track readiness\n\n  var storeReady = true;\n  store.on('disconnect', function ondisconnect() {\n    storeReady = false;\n  });\n  store.on('connect', function onconnect() {\n    storeReady = true;\n  });\n  return function session(req, res, next) {\n    // self-awareness\n    if (req.session) {\n      next();\n      return;\n    } // Handle connection as if there is no session if\n    // the store has temporarily disconnected etc\n\n\n    if (!storeReady) {\n      debug('store is disconnected');\n      next();\n      return;\n    } // pathname mismatch\n\n\n    var originalPath = parseUrl.original(req).pathname || '/';\n    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) return next(); // ensure a secret is available or bail\n\n    if (!secret && !req.secret) {\n      next(new Error('secret option required for sessions'));\n      return;\n    } // backwards compatibility for signed cookies\n    // req.secret is passed from the cookie parser middleware\n\n\n    var secrets = secret || [req.secret];\n    var originalHash;\n    var originalId;\n    var savedHash;\n    var touched = false; // expose store\n\n    req.sessionStore = store; // get the session ID from the cookie\n\n    var cookieId = req.sessionID = getcookie(req, name, secrets); // set-cookie\n\n    onHeaders(res, function () {\n      if (!req.session) {\n        debug('no session');\n        return;\n      }\n\n      if (!shouldSetCookie(req)) {\n        return;\n      } // only send secure cookies via https\n\n\n      if (req.session.cookie.secure && !issecure(req, trustProxy)) {\n        debug('not secured');\n        return;\n      }\n\n      if (!touched) {\n        // touch session\n        req.session.touch();\n        touched = true;\n      } // set cookie\n\n\n      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);\n    }); // proxy end() to commit the session\n\n    var _end = res.end;\n    var _write = res.write;\n    var ended = false;\n\n    res.end = function end(chunk, encoding) {\n      if (ended) {\n        return false;\n      }\n\n      ended = true;\n      var ret;\n      var sync = true;\n\n      function writeend() {\n        if (sync) {\n          ret = _end.call(res, chunk, encoding);\n          sync = false;\n          return;\n        }\n\n        _end.call(res);\n      }\n\n      function writetop() {\n        if (!sync) {\n          return ret;\n        }\n\n        if (!res._header) {\n          res._implicitHeader();\n        }\n\n        if (chunk == null) {\n          ret = true;\n          return ret;\n        }\n\n        var contentLength = Number(res.getHeader('Content-Length'));\n\n        if (!isNaN(contentLength) && contentLength > 0) {\n          // measure chunk\n          chunk = !Buffer.isBuffer(chunk) ? Buffer.from(chunk, encoding) : chunk;\n          encoding = undefined;\n\n          if (chunk.length !== 0) {\n            debug('split response');\n            ret = _write.call(res, chunk.slice(0, chunk.length - 1));\n            chunk = chunk.slice(chunk.length - 1, chunk.length);\n            return ret;\n          }\n        }\n\n        ret = _write.call(res, chunk, encoding);\n        sync = false;\n        return ret;\n      }\n\n      if (shouldDestroy(req)) {\n        // destroy session\n        debug('destroying');\n        store.destroy(req.sessionID, function ondestroy(err) {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug('destroyed');\n          writeend();\n        });\n        return writetop();\n      } // no session to save\n\n\n      if (!req.session) {\n        debug('no session');\n        return _end.call(res, chunk, encoding);\n      }\n\n      if (!touched) {\n        // touch session\n        req.session.touch();\n        touched = true;\n      }\n\n      if (shouldSave(req)) {\n        req.session.save(function onsave(err) {\n          if (err) {\n            defer(next, err);\n          }\n\n          writeend();\n        });\n        return writetop();\n      } else if (storeImplementsTouch && shouldTouch(req)) {\n        // store implements touch method\n        debug('touching');\n        store.touch(req.sessionID, req.session, function ontouch(err) {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug('touched');\n          writeend();\n        });\n        return writetop();\n      }\n\n      return _end.call(res, chunk, encoding);\n    }; // generate the session\n\n\n    function generate() {\n      store.generate(req);\n      originalId = req.sessionID;\n      originalHash = hash(req.session);\n      wrapmethods(req.session);\n    } // inflate the session\n\n\n    function inflate(req, sess) {\n      store.createSession(req, sess);\n      originalId = req.sessionID;\n      originalHash = hash(sess);\n\n      if (!resaveSession) {\n        savedHash = originalHash;\n      }\n\n      wrapmethods(req.session);\n    }\n\n    function rewrapmethods(sess, callback) {\n      return function () {\n        if (req.session !== sess) {\n          wrapmethods(req.session);\n        }\n\n        callback.apply(this, arguments);\n      };\n    } // wrap session methods\n\n\n    function wrapmethods(sess) {\n      var _reload = sess.reload;\n      var _save = sess.save;\n\n      function reload(callback) {\n        debug('reloading %s', this.id);\n\n        _reload.call(this, rewrapmethods(this, callback));\n      }\n\n      function save() {\n        debug('saving %s', this.id);\n        savedHash = hash(this);\n\n        _save.apply(this, arguments);\n      }\n\n      Object.defineProperty(sess, 'reload', {\n        configurable: true,\n        enumerable: false,\n        value: reload,\n        writable: true\n      });\n      Object.defineProperty(sess, 'save', {\n        configurable: true,\n        enumerable: false,\n        value: save,\n        writable: true\n      });\n    } // check if session has been modified\n\n\n    function isModified(sess) {\n      return originalId !== sess.id || originalHash !== hash(sess);\n    } // check if session has been saved\n\n\n    function isSaved(sess) {\n      return originalId === sess.id && savedHash === hash(sess);\n    } // determine if session should be destroyed\n\n\n    function shouldDestroy(req) {\n      return req.sessionID && unsetDestroy && req.session == null;\n    } // determine if session should be saved to store\n\n\n    function shouldSave(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        debug('session ignored because of bogus req.sessionID %o', req.sessionID);\n        return false;\n      }\n\n      return !saveUninitializedSession && cookieId !== req.sessionID ? isModified(req.session) : !isSaved(req.session);\n    } // determine if session should be touched\n\n\n    function shouldTouch(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        debug('session ignored because of bogus req.sessionID %o', req.sessionID);\n        return false;\n      }\n\n      return cookieId === req.sessionID && !shouldSave(req);\n    } // determine if cookie should be set on response\n\n\n    function shouldSetCookie(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        return false;\n      }\n\n      return cookieId !== req.sessionID ? saveUninitializedSession || isModified(req.session) : rollingSessions || req.session.cookie.expires != null && isModified(req.session);\n    } // generate a session if the browser doesn't send a sessionID\n\n\n    if (!req.sessionID) {\n      debug('no SID sent, generating session');\n      generate();\n      next();\n      return;\n    } // generate the session object\n\n\n    debug('fetching %s', req.sessionID);\n    store.get(req.sessionID, function (err, sess) {\n      // error handling\n      if (err && err.code !== 'ENOENT') {\n        debug('error %j', err);\n        next(err);\n        return;\n      }\n\n      try {\n        if (err || !sess) {\n          debug('no session found');\n          generate();\n        } else {\n          debug('session found');\n          inflate(req, sess);\n        }\n      } catch (e) {\n        next(e);\n        return;\n      }\n\n      next();\n    });\n  };\n}\n\n;\n/**\n * Generate a session ID for a new session.\n *\n * @return {String}\n * @private\n */\n\nfunction generateSessionId(sess) {\n  return uid(24);\n}\n/**\n * Get the session ID cookie from request.\n *\n * @return {string}\n * @private\n */\n\n\nfunction getcookie(req, name, secrets) {\n  var header = req.headers.cookie;\n  var raw;\n  var val; // read from cookie header\n\n  if (header) {\n    var cookies = cookie.parse(header);\n    raw = cookies[name];\n\n    if (raw) {\n      if (raw.substr(0, 2) === 's:') {\n        val = unsigncookie(raw.slice(2), secrets);\n\n        if (val === false) {\n          debug('cookie signature invalid');\n          val = undefined;\n        }\n      } else {\n        debug('cookie unsigned');\n      }\n    }\n  } // back-compat read from cookieParser() signedCookies data\n\n\n  if (!val && req.signedCookies) {\n    val = req.signedCookies[name];\n\n    if (val) {\n      deprecate('cookie should be available in req.headers.cookie');\n    }\n  } // back-compat read from cookieParser() cookies data\n\n\n  if (!val && req.cookies) {\n    raw = req.cookies[name];\n\n    if (raw) {\n      if (raw.substr(0, 2) === 's:') {\n        val = unsigncookie(raw.slice(2), secrets);\n\n        if (val) {\n          deprecate('cookie should be available in req.headers.cookie');\n        }\n\n        if (val === false) {\n          debug('cookie signature invalid');\n          val = undefined;\n        }\n      } else {\n        debug('cookie unsigned');\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * Hash the given `sess` object omitting changes to `.cookie`.\n *\n * @param {Object} sess\n * @return {String}\n * @private\n */\n\n\nfunction hash(sess) {\n  // serialize\n  var str = JSON.stringify(sess, function (key, val) {\n    // ignore sess.cookie property\n    if (this === sess && key === 'cookie') {\n      return;\n    }\n\n    return val;\n  }); // hash\n\n  return crypto.createHash('sha1').update(str, 'utf8').digest('hex');\n}\n/**\n * Determine if request is secure.\n *\n * @param {Object} req\n * @param {Boolean} [trustProxy]\n * @return {Boolean}\n * @private\n */\n\n\nfunction issecure(req, trustProxy) {\n  // socket is https server\n  if (req.connection && req.connection.encrypted) {\n    return true;\n  } // do not trust proxy\n\n\n  if (trustProxy === false) {\n    return false;\n  } // no explicit trust; try req.secure from express\n\n\n  if (trustProxy !== true) {\n    return req.secure === true;\n  } // read the proto from x-forwarded-proto header\n\n\n  var header = req.headers['x-forwarded-proto'] || '';\n  var index = header.indexOf(',');\n  var proto = index !== -1 ? header.substr(0, index).toLowerCase().trim() : header.toLowerCase().trim();\n  return proto === 'https';\n}\n/**\n * Set cookie on response.\n *\n * @private\n */\n\n\nfunction setcookie(res, name, val, secret, options) {\n  var signed = 's:' + signature.sign(val, secret);\n  var data = cookie.serialize(name, signed, options);\n  debug('set-cookie %s', data);\n  var prev = res.getHeader('Set-Cookie') || [];\n  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];\n  res.setHeader('Set-Cookie', header);\n}\n/**\n * Verify and decode the given `val` with `secrets`.\n *\n * @param {String} val\n * @param {Array} secrets\n * @returns {String|Boolean}\n * @private\n */\n\n\nfunction unsigncookie(val, secrets) {\n  for (var i = 0; i < secrets.length; i++) {\n    var result = signature.unsign(val, secrets[i]);\n\n    if (result !== false) {\n      return result;\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack:///./node_modules/express-session/index.js?");

/***/ }),

/***/ "./node_modules/express-session/session/cookie.js":
/*!********************************************************!*\
  !*** ./node_modules/express-session/session/cookie.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * Connect - session - Cookie\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar cookie = __webpack_require__(/*! cookie */ \"cookie\");\n\nvar deprecate = __webpack_require__(/*! depd */ \"depd\")('express-session');\n/**\n * Initialize a new `Cookie` with the given `options`.\n *\n * @param {IncomingMessage} req\n * @param {Object} options\n * @api private\n */\n\n\nvar Cookie = module.exports = function Cookie(options) {\n  this.path = '/';\n  this.maxAge = null;\n  this.httpOnly = true;\n\n  if (options) {\n    if (typeof options !== 'object') {\n      throw new TypeError('argument options must be a object');\n    }\n\n    for (var key in options) {\n      if (key !== 'data') {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  if (this.originalMaxAge === undefined || this.originalMaxAge === null) {\n    this.originalMaxAge = this.maxAge;\n  }\n};\n/*!\n * Prototype.\n */\n\n\nCookie.prototype = {\n  /**\n   * Set expires `date`.\n   *\n   * @param {Date} date\n   * @api public\n   */\n  set expires(date) {\n    this._expires = date;\n    this.originalMaxAge = this.maxAge;\n  },\n\n  /**\n   * Get expires `date`.\n   *\n   * @return {Date}\n   * @api public\n   */\n  get expires() {\n    return this._expires;\n  },\n\n  /**\n   * Set expires via max-age in `ms`.\n   *\n   * @param {Number} ms\n   * @api public\n   */\n  set maxAge(ms) {\n    if (ms && typeof ms !== 'number' && !(ms instanceof Date)) {\n      throw new TypeError('maxAge must be a number or Date');\n    }\n\n    if (ms instanceof Date) {\n      deprecate('maxAge as Date; pass number of milliseconds instead');\n    }\n\n    this.expires = typeof ms === 'number' ? new Date(Date.now() + ms) : ms;\n  },\n\n  /**\n   * Get expires max-age in `ms`.\n   *\n   * @return {Number}\n   * @api public\n   */\n  get maxAge() {\n    return this.expires instanceof Date ? this.expires.valueOf() - Date.now() : this.expires;\n  },\n\n  /**\n   * Return cookie data object.\n   *\n   * @return {Object}\n   * @api private\n   */\n  get data() {\n    return {\n      originalMaxAge: this.originalMaxAge,\n      expires: this._expires,\n      secure: this.secure,\n      httpOnly: this.httpOnly,\n      domain: this.domain,\n      path: this.path,\n      sameSite: this.sameSite\n    };\n  },\n\n  /**\n   * Return a serialized cookie string.\n   *\n   * @return {String}\n   * @api public\n   */\n  serialize: function (name, val) {\n    return cookie.serialize(name, val, this.data);\n  },\n\n  /**\n   * Return JSON representation of this cookie.\n   *\n   * @return {Object}\n   * @api private\n   */\n  toJSON: function () {\n    return this.data;\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/express-session/session/cookie.js?");

/***/ }),

/***/ "./node_modules/express-session/session/memory.js":
/*!********************************************************!*\
  !*** ./node_modules/express-session/session/memory.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * express-session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Store = __webpack_require__(/*! ./store */ \"./node_modules/express-session/session/store.js\");\n\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * Shim setImmediate for node.js < 0.10\n * @private\n */\n\n/* istanbul ignore next */\n\n\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n/**\n * Module exports.\n */\n\nmodule.exports = MemoryStore;\n/**\n * A session store in memory.\n * @public\n */\n\nfunction MemoryStore() {\n  Store.call(this);\n  this.sessions = Object.create(null);\n}\n/**\n * Inherit from Store.\n */\n\n\nutil.inherits(MemoryStore, Store);\n/**\n * Get all active sessions.\n *\n * @param {function} callback\n * @public\n */\n\nMemoryStore.prototype.all = function all(callback) {\n  var sessionIds = Object.keys(this.sessions);\n  var sessions = Object.create(null);\n\n  for (var i = 0; i < sessionIds.length; i++) {\n    var sessionId = sessionIds[i];\n    var session = getSession.call(this, sessionId);\n\n    if (session) {\n      sessions[sessionId] = session;\n    }\n  }\n\n  callback && defer(callback, null, sessions);\n};\n/**\n * Clear all sessions.\n *\n * @param {function} callback\n * @public\n */\n\n\nMemoryStore.prototype.clear = function clear(callback) {\n  this.sessions = Object.create(null);\n  callback && defer(callback);\n};\n/**\n * Destroy the session associated with the given session ID.\n *\n * @param {string} sessionId\n * @public\n */\n\n\nMemoryStore.prototype.destroy = function destroy(sessionId, callback) {\n  delete this.sessions[sessionId];\n  callback && defer(callback);\n};\n/**\n * Fetch session by the given session ID.\n *\n * @param {string} sessionId\n * @param {function} callback\n * @public\n */\n\n\nMemoryStore.prototype.get = function get(sessionId, callback) {\n  defer(callback, null, getSession.call(this, sessionId));\n};\n/**\n * Commit the given session associated with the given sessionId to the store.\n *\n * @param {string} sessionId\n * @param {object} session\n * @param {function} callback\n * @public\n */\n\n\nMemoryStore.prototype.set = function set(sessionId, session, callback) {\n  this.sessions[sessionId] = JSON.stringify(session);\n  callback && defer(callback);\n};\n/**\n * Get number of active sessions.\n *\n * @param {function} callback\n * @public\n */\n\n\nMemoryStore.prototype.length = function length(callback) {\n  this.all(function (err, sessions) {\n    if (err) return callback(err);\n    callback(null, Object.keys(sessions).length);\n  });\n};\n/**\n * Touch the given session object associated with the given session ID.\n *\n * @param {string} sessionId\n * @param {object} session\n * @param {function} callback\n * @public\n */\n\n\nMemoryStore.prototype.touch = function touch(sessionId, session, callback) {\n  var currentSession = getSession.call(this, sessionId);\n\n  if (currentSession) {\n    // update expiration\n    currentSession.cookie = session.cookie;\n    this.sessions[sessionId] = JSON.stringify(currentSession);\n  }\n\n  callback && defer(callback);\n};\n/**\n * Get session from the store.\n * @private\n */\n\n\nfunction getSession(sessionId) {\n  var sess = this.sessions[sessionId];\n\n  if (!sess) {\n    return;\n  } // parse\n\n\n  sess = JSON.parse(sess);\n\n  if (sess.cookie) {\n    var expires = typeof sess.cookie.expires === 'string' ? new Date(sess.cookie.expires) : sess.cookie.expires; // destroy expired session\n\n    if (expires && expires <= Date.now()) {\n      delete this.sessions[sessionId];\n      return;\n    }\n  }\n\n  return sess;\n}\n\n//# sourceURL=webpack:///./node_modules/express-session/session/memory.js?");

/***/ }),

/***/ "./node_modules/express-session/session/session.js":
/*!*********************************************************!*\
  !*** ./node_modules/express-session/session/session.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * Connect - session - Session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Expose Session.\n */\n\nmodule.exports = Session;\n/**\n * Create a new `Session` with the given request and `data`.\n *\n * @param {IncomingRequest} req\n * @param {Object} data\n * @api private\n */\n\nfunction Session(req, data) {\n  Object.defineProperty(this, 'req', {\n    value: req\n  });\n  Object.defineProperty(this, 'id', {\n    value: req.sessionID\n  });\n\n  if (typeof data === 'object' && data !== null) {\n    // merge data into this, ignoring prototype properties\n    for (var prop in data) {\n      if (!(prop in this)) {\n        this[prop] = data[prop];\n      }\n    }\n  }\n}\n/**\n * Update reset `.cookie.maxAge` to prevent\n * the cookie from expiring when the\n * session is still active.\n *\n * @return {Session} for chaining\n * @api public\n */\n\n\ndefineMethod(Session.prototype, 'touch', function touch() {\n  return this.resetMaxAge();\n});\n/**\n * Reset `.maxAge` to `.originalMaxAge`.\n *\n * @return {Session} for chaining\n * @api public\n */\n\ndefineMethod(Session.prototype, 'resetMaxAge', function resetMaxAge() {\n  this.cookie.maxAge = this.cookie.originalMaxAge;\n  return this;\n});\n/**\n * Save the session data with optional callback `fn(err)`.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\ndefineMethod(Session.prototype, 'save', function save(fn) {\n  this.req.sessionStore.set(this.id, this, fn || function () {});\n  return this;\n});\n/**\n * Re-loads the session data _without_ altering\n * the maxAge properties. Invokes the callback `fn(err)`,\n * after which time if no exception has occurred the\n * `req.session` property will be a new `Session` object,\n * although representing the same session.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\ndefineMethod(Session.prototype, 'reload', function reload(fn) {\n  var req = this.req;\n  var store = this.req.sessionStore;\n  store.get(this.id, function (err, sess) {\n    if (err) return fn(err);\n    if (!sess) return fn(new Error('failed to load session'));\n    store.createSession(req, sess);\n    fn();\n  });\n  return this;\n});\n/**\n * Destroy `this` session.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\ndefineMethod(Session.prototype, 'destroy', function destroy(fn) {\n  delete this.req.session;\n  this.req.sessionStore.destroy(this.id, fn);\n  return this;\n});\n/**\n * Regenerate this request's session.\n *\n * @param {Function} fn\n * @return {Session} for chaining\n * @api public\n */\n\ndefineMethod(Session.prototype, 'regenerate', function regenerate(fn) {\n  this.req.sessionStore.regenerate(this.req, fn);\n  return this;\n});\n/**\n * Helper function for creating a method on a prototype.\n *\n * @param {Object} obj\n * @param {String} name\n * @param {Function} fn\n * @private\n */\n\nfunction defineMethod(obj, name, fn) {\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: false,\n    value: fn,\n    writable: true\n  });\n}\n\n;\n\n//# sourceURL=webpack:///./node_modules/express-session/session/session.js?");

/***/ }),

/***/ "./node_modules/express-session/session/store.js":
/*!*******************************************************!*\
  !*** ./node_modules/express-session/session/store.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * Connect - session - Store\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Cookie = __webpack_require__(/*! ./cookie */ \"./node_modules/express-session/session/cookie.js\");\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nvar Session = __webpack_require__(/*! ./session */ \"./node_modules/express-session/session/session.js\");\n\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * Module exports.\n * @public\n */\n\n\nmodule.exports = Store;\n/**\n * Abstract base class for session stores.\n * @public\n */\n\nfunction Store() {\n  EventEmitter.call(this);\n}\n/**\n * Inherit from EventEmitter.\n */\n\n\nutil.inherits(Store, EventEmitter);\n/**\n * Re-generate the given requests's session.\n *\n * @param {IncomingRequest} req\n * @return {Function} fn\n * @api public\n */\n\nStore.prototype.regenerate = function (req, fn) {\n  var self = this;\n  this.destroy(req.sessionID, function (err) {\n    self.generate(req);\n    fn(err);\n  });\n};\n/**\n * Load a `Session` instance via the given `sid`\n * and invoke the callback `fn(err, sess)`.\n *\n * @param {String} sid\n * @param {Function} fn\n * @api public\n */\n\n\nStore.prototype.load = function (sid, fn) {\n  var self = this;\n  this.get(sid, function (err, sess) {\n    if (err) return fn(err);\n    if (!sess) return fn();\n    var req = {\n      sessionID: sid,\n      sessionStore: self\n    };\n    fn(null, self.createSession(req, sess));\n  });\n};\n/**\n * Create session from JSON `sess` data.\n *\n * @param {IncomingRequest} req\n * @param {Object} sess\n * @return {Session}\n * @api private\n */\n\n\nStore.prototype.createSession = function (req, sess) {\n  var expires = sess.cookie.expires;\n  var originalMaxAge = sess.cookie.originalMaxAge;\n  sess.cookie = new Cookie(sess.cookie);\n\n  if (typeof expires === 'string') {\n    // convert expires to a Date object\n    sess.cookie.expires = new Date(expires);\n  } // keep originalMaxAge intact\n\n\n  sess.cookie.originalMaxAge = originalMaxAge;\n  req.session = new Session(req, sess);\n  return req.session;\n};\n\n//# sourceURL=webpack:///./node_modules/express-session/session/store.js?");

/***/ }),

/***/ "./node_modules/filter-obj/index.js":
/*!******************************************!*\
  !*** ./node_modules/filter-obj/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (obj, predicate) {\n  var ret = {};\n  var keys = Object.keys(obj);\n  var isArr = Array.isArray(predicate);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var val = obj[key];\n\n    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {\n      ret[key] = val;\n    }\n  }\n\n  return ret;\n};\n\n//# sourceURL=webpack:///./node_modules/filter-obj/index.js?");

/***/ }),

/***/ "./node_modules/kruptein/index.js":
/*!****************************************!*\
  !*** ./node_modules/kruptein/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * kruptein\n * Copyright(c) 2019 Jason Gerfen <jason.gerfen@gmail.com>\n * License: MIT\n */\nmodule.exports = __webpack_require__(/*! ./lib/kruptein.js */ \"./node_modules/kruptein/lib/kruptein.js\");\n\n//# sourceURL=webpack:///./node_modules/kruptein/index.js?");

/***/ }),

/***/ "./node_modules/kruptein/lib/kruptein.js":
/*!***********************************************!*\
  !*** ./node_modules/kruptein/lib/kruptein.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * kruptein\n * Copyright(c) 2019 Jason Gerfen <jason.gerfen@gmail.com>\n * License: MIT\n */\n\n\nclass Kruptein {\n  /**\n   * Kruptein class constructor; sets private / public defaults\n   * @param {object} options User supplied key / value object\n   */\n  constructor(options) {\n    options = options || {};\n    this.crypto = __webpack_require__(/*! crypto */ \"crypto\"); // Set defaults if the user didn't supply any\n    //   References: SP 800-38A, 800-38B\n\n    this._algorithm = options.algorithm || \"aes-256-gcm\";\n    this._hashing = options.hashing || \"sha512\";\n    this._encodeas = options.encodeas || \"base64\";\n    this._use_asn1 = options.use_asn1 || true; // Are we using AEAD mode (authenticated ciphers)?\n    //   References: SP 800-38A, 800-38B\n\n    this._aead_mode = this._algorithm.match(/ccm|gcm|ocb/) ? true : false; // Set some defaults based on the algorithm used\n    //   References: SP 800-38A, 800-38B, 800-107, 800-131A\n\n    let defaults = this._matrix(this._algorithm);\n\n    this._at_size = options._at_size || defaults._at_size;\n    this._iv_size = options._iv_size || defaults._iv_size;\n    this._key_size = options._key_size || defaults._key_size; // Replace pbkdf2 with scrypt for key derivation?\n    //   References: SP 800-108 & 800-132\n\n    this._use_scrypt = options.use_scrypt || false; // Use asn.1 encoding?\n\n    if (this._use_asn1) {\n      this.asn1 = __webpack_require__(/*! asn1.js */ \"asn1.js\");\n      this.schema = this._schema();\n    }\n  }\n  /**\n   * Public interface for creating ciphertext from plaintext\n   * @param {string} secret User supplied key material\n   * @param {string} plaintext User supplied plaintext\n   * @param {string} aad (optional) User supplied additional authentication data\n   * @param {function} cb User supplied callback function\n   * @returns {object}\n   */\n\n\n  set(secret, plaintext, aad, cb) {\n    // If non-aead cipher then expect 3 vs. 4 args\n    cb = cb || aad; // Initialize some defaults\n\n    let iv, ct, hmac, obj, key; // Bail if using weak cipher algorithm modes\n    //   References: SP 800-38A, 800-38B, 800-131A & 800-175B\n\n    if (this._validator()) return cb(\"Insecure cipher mode not supported!\"); // Bail if secret is not provided\n\n    if (!secret) return cb(\"Must supply a secret!\"); // Derive a stronger key from secret;\n    //   References: SP 800-57P1, 800-108, 800-132 & 800-175B\n\n    this._derive_key(secret, (err, secret) => {\n      if (err) return cb(\"Unable to derive key!\");\n      key = secret;\n    }); // Generate a random IV based on the algorithms IV size\n    //   References: RFC 4086, SP 800-57P1, 800-132 & 800-175B\n\n\n    iv = this._iv(this._iv_size); // Are we dealing with an object?\n\n    let pt = plaintext;\n\n    try {\n      plaintext = Buffer.from(JSON.stringify(pt));\n    } catch (err) {\n      plaintext = Buffer.from(pt);\n    } // If AEAD mode cipher used and an AAD not provided, create one\n    //   References: SP 800-38A, 800-38B, 800-131A & 800-175B\n\n\n    if (this._aead_mode && typeof aad === \"function\") {\n      this._digest(this._iv(128), plaintext, this._hashing, this._encodeas, (err, res) => {\n        if (err) return cb(\"Unable to generate AAD!\");\n        aad = res;\n      });\n    } // Create ciphertext from plaintext with derived key\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n\n    this._encrypt(key.key, plaintext, this._algorithm, this._encodeas, iv, aad, (err, ciphertext) => {\n      if (err) return cb(\"Unable to create ciphertext!\");\n      ct = ciphertext;\n    }); // Create an HMAC from the resulting ciphertext\n    //   References: FIPS 180-4, FIPS 198-1\n\n\n    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, digest) => {\n      if (err) return cb(\"Unable to create digest!\");\n      hmac = digest;\n    }); // Create an object to pass back\n\n\n    obj = {\n      hmac: hmac,\n      ct: ct.ct,\n      iv: iv,\n      salt: key.salt\n    }; // If AEAD mode include the AAD\n\n    if (aad) obj.aad = aad; // If AEAD mode include the AT\n\n    if (ct.at) obj.at = ct.at; // Make sure the retured object is encoded property\n\n    return this._use_asn1 ? cb(null, this.schema.encode(obj).toString(this._encodeas)) : cb(null, JSON.stringify(obj));\n  }\n  /**\n   * Public interface for decrypting plaintext\n   * @param {string} secret User supplied key material\n   * @param {string} ciphertext User supplied ciphertext\n   * @param {object} opts (optional) User supplied AEAD mode data\n   * @param {function} cb User supplied callback function\n   * @returns {object}\n   */\n\n\n  get(secret, ciphertext, opts, cb) {\n    // If non-aead cipher then expect 3 vs. 4 args\n    cb = cb || opts; // Initialize some defaults\n\n    let ct, hmac, pt, key; // Bail if using weak cipher algorithm modes\n    //   References: SP 800-38A, 800-38B, 800-131A & 800-175B\n\n    if (this._validator()) return cb(\"Insecure cipher mode not supported!\"); // Bail if secret is not provided\n\n    if (!secret) return cb(\"Must supply a secret!\"); // Parse the provided ciphertext object or bail\n\n    try {\n      if (this._use_asn1) {\n        ct = this.schema.decode(Buffer.from(ciphertext, this._encodeas));\n        if (ct.at) ct.ct = ct.ct.toString();\n        if (ct.aad) ct.aad = ct.aad.toString();\n      } else {\n        ct = JSON.parse(ciphertext);\n      }\n    } catch (err) {\n      return cb(\"Unable to parse ciphertext object!\");\n    } // Derive a stronger key from secret;\n    //   References: SP 800-57P1, 800-108, 800-132 & 800-175B\n\n\n    this._derive_key(secret, ct.salt, (err, secret) => {\n      if (err) return cb(\"Unable to derive key!\");\n      key = secret;\n    }); // Create an HMAC from the ciphertext HMAC value\n    //   References: FIPS 180-4, FIPS 198-1\n\n\n    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, res) => {\n      if (err) cb(\"Unable to generate HMAC!\");\n      hmac = res;\n    }); // Compare computed from included & bail if not identical\n    //   References: Oracle padding attack, side channel attacks & malleable\n\n\n    if (hmac !== ct.hmac.toString()) return cb(\"Encrypted session was tampered with!\"); // If provided get the AAD &/or AT values\n\n    if (opts) {\n      ct.aad = opts.aad ? opts.aad : ct.aad ? ct.aad : false;\n      ct.at = opts.at && !ct.at ? opts.at : ct.at ? ct.at : false;\n    } // Convert the AT to a buffer\n\n\n    if (ct.at) ct.at = Buffer.from(ct.at, this._encodeas); // Create plaintext from ciphertext with derived key\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n    this._decrypt(key.key, ct.ct, this._algorithm, this._encodeas, Buffer.from(ct.iv, this._encodeas), ct.at, ct.aad, (err, res) => {\n      if (err) return cb(\"Unable to decrypt ciphertext!\");\n      pt = res;\n    });\n\n    return cb(null, pt);\n  }\n  /**\n   * Private function to encrypt plaintext\n   * @param {buffer} key Derived key material\n   * @param {string} pt User supplied plaintext\n   * @param {string} algo Cipher to encrypt with\n   * @param {string} encodeas Encoding output format\n   * @param {buffer} iv Unique IV\n   * @param {string} aad (optional) AAD for AEAD mode ciphers\n   * @param {function} cb User supplied callback function\n   * @returns {object}\n   */\n\n\n  _encrypt(key, pt, algo, encodeas, iv, aad, cb) {\n    // If non-aead cipher then expect 6 vs. 7 args\n    cb = cb || aad; // Initialize some defaults\n\n    let cipher, ct, at; // Create a new cipher object using algorithm, derived key & iv\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n    cipher = this.crypto.createCipheriv(algo, key, iv, {\n      authTagLength: this._at_size\n    }); // If an AEAD cipher is used & an AAD supplied, include it\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n    if (this._aead_mode && typeof aad !== \"function\") {\n      try {\n        cipher.setAAD(Buffer.from(aad, encodeas), {\n          plaintextLength: Buffer.byteLength(pt)\n        });\n      } catch (err) {\n        return cb(\"Unable to set AAD!\");\n      }\n    } // Add our plaintext; encode & pad the resulting cipher text\n\n\n    ct = cipher.update(Buffer.from(pt, encodeas), \"utf8\", encodeas);\n    cipher.setAutoPadding(true);\n    ct += cipher.final(encodeas); // If an AEAD cipher is used, retrieve the authentication tag\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n    if (this._aead_mode) {\n      try {\n        at = cipher.getAuthTag();\n      } catch (err) {\n        return cb(\"Unable to obtain authentication tag\");\n      }\n    } // Return the object\n\n\n    return cb(null, at ? {\n      \"ct\": ct,\n      \"at\": at\n    } : {\n      \"ct\": ct\n    });\n  }\n  /**\n   * Private function to decrypt ciphertext\n   * @param {buffer} key Derived key material\n   * @param {object} ct User supplied ciphertext object\n   * @param {string} algo Cipher to encrypt with\n   * @param {string} encodeas Encoding output format\n   * @param {buffer} iv Unique IV\n   * @param {string} at (optional) AT for AEAD mode ciphers\n   * @param {string} aad (optional) AAD for AEAD mode ciphers\n   * @param {function} cb User supplied callback function\n   * @returns {object}\n   */\n\n\n  _decrypt(key, ct, algo, encodeas, iv, at, aad, cb) {\n    // If non-aead cipher then expect 6 vs. 7 args\n    cb = cb || aad; // Initialize some defaults\n\n    let cipher, pt; // Create a new de-cipher object using algorithm, derived key & iv\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n    cipher = this.crypto.createDecipheriv(algo, key, iv, {\n      authTagLength: this._at_size\n    }); // If an AEAD cipher is used & an AT supplied, include it\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n    if (this._aead_mode && at) {\n      try {\n        cipher.setAuthTag(Buffer.from(at, encodeas));\n      } catch (err) {\n        return cb(\"Unable to set authentication tag\");\n      }\n    } // If an AEAD cipher is used & an AAD supplied, include it\n    //   References: SP 800-38A, 800-38B, 800-131A, 800-175B, FIPS 197 & 198-1\n\n\n    if (this._aead_mode && typeof aad !== \"function\") {\n      try {\n        cipher.setAAD(Buffer.from(aad, encodeas), {\n          plaintextLength: ct.length\n        });\n      } catch (err) {\n        return cb(\"Unable to set additional authentication data\");\n      }\n    } // Add our ciphertext & encode\n\n\n    try {\n      pt = cipher.update(ct, encodeas, \"utf8\");\n      pt += cipher.final(\"utf8\");\n    } catch (err) {\n      return cb(\"Unable to decrypt ciphertext!\");\n    } // return the plaintext\n\n\n    return cb(null, pt);\n  }\n  /**\n   * Private function to derive a secret key\n   * @param {string} secret User supplied key material\n   * @param {buffer} salt Unique salt\n   * @param {function} cb User supplied callback function\n   * @returns {object}\n   */\n\n\n  _derive_key(secret, salt, cb) {\n    // If salt not supplied then expect 2 vs. 3 args\n    cb = cb || salt; // Initialize some defaults\n\n    let key,\n        opts = {}; // If secret is an object then extract the parts; test harness only\n\n    if (typeof secret === \"object\") {\n      opts = secret.opts;\n      secret = secret.secret;\n    } // If a salt was NOT supplied, create one\n    //   References: RFC 4086, 5084, SP 800-57P1, 800-108 & 800-132\n\n\n    salt = typeof salt !== \"function\" ? Buffer.from(salt) : this.crypto.randomBytes(128); // PBKDF2 or scrypt key derivation logic\n    //   References: RFC 4086, 5084, SP 800-57P1, 800-108 & 800-132\n    //   Compliance: If scrypt used does not conform to FIPS!\n\n    try {\n      if (!this._use_scrypt || typeof this.crypto.scryptSync !== \"function\") {\n        key = this.crypto.pbkdf2Sync(secret, salt, 15000, this._key_size, this._hashing);\n      } else {\n        key = this.crypto.scryptSync(secret, salt, this._key_size, opts);\n      }\n    } catch (err) {\n      return cb(\"Unable to derive key!\");\n    } // Return the derived key and salt\n\n\n    return cb(null, {\n      key: key,\n      salt: salt\n    });\n  }\n  /**\n   * Private function to generate an HMAC\n   * @param {string} key User supplied key material\n   * @param {string} obj User supplied content to create HMAC from\n   * @param {string} hashing Selected hashing algorithm\n   * @param {string} encodeas Resulting encoding\n   * @param {function} cb User supplied callback function\n   * @returns {object}\n   */\n\n\n  _digest(key, obj, hashing, encodeas, cb) {\n    // Initialize some defaults\n    let hmac; // Create an HMAC from the supplied data\n    //   References: SP 800-175B, FIPS 180-4 & FIPS 198-1\n\n    try {\n      hmac = this.crypto.createHmac(hashing, key);\n      hmac.setEncoding(encodeas);\n      hmac.write(obj);\n      hmac.end();\n    } catch (err) {\n      return cb(\"Unable to generate digest!\");\n    } // Return digest\n\n\n    return cb(null, hmac.read().toString(encodeas));\n  }\n  /**\n   * Private function to generate a random value\n   * @param {integer} iv_size The random buffer size\n   * @returns {buffer}\n   */\n\n\n  _iv(iv_size) {\n    return this.crypto.randomBytes(iv_size);\n  }\n  /**\n   * Private function to generate object of algorithm key, iv & at sizes\n   * @param {string} algo The cipher name\n   * @returns {object}\n   */\n\n\n  _matrix(algo) {\n    let obj = {\n      _at_size: 16,\n      _iv_size: 16,\n      _key_size: 32\n    };\n    if (algo.match(/ccm|ocb|gcm/i)) obj._iv_size = 12;\n    if (algo.match(/aes/) && algo.match(/128/)) obj._key_size = 16;\n    if (algo.match(/aes/) && algo.match(/192/)) obj._key_size = 24;\n    if (algo.match(/aes/) && algo.match(/xts/)) obj._key_size = 32;\n    if (algo.match(/aes/) && algo.match(/xts/) && algo.match(/256/)) obj._key_size = 64;\n    return obj;\n  }\n  /**\n   * Look for insecure modes\n   * @returns {boolean}\n   */\n\n\n  _validator() {\n    return this._algorithm.match(/ccm|ecb|ocb2/);\n  }\n  /**\n   * When encoding as asn.1 define a schema\n   * @returns {object}\n   */\n\n\n  _schema() {\n    let schema;\n\n    if (!this._aead_mode) {\n      schema = this.asn1.define('schema', function () {\n        this.seq().obj(this.key(\"ct\").octstr(), this.key(\"hmac\").octstr(), this.key(\"iv\").octstr(), this.key(\"salt\").octstr());\n      });\n    } else {\n      schema = this.asn1.define('schema', function () {\n        this.seq().obj(this.key(\"ct\").octstr(), this.key(\"hmac\").octstr(), this.key(\"iv\").octstr(), this.key(\"salt\").octstr(), this.key(\"at\").octstr(), this.key(\"aad\").octstr());\n      });\n    }\n\n    return schema;\n  }\n\n}\n/**\n * Robot, do work\n */\n\n\nmodule.exports = function (options) {\n  return new Kruptein(options || {});\n};\n\n//# sourceURL=webpack:///./node_modules/kruptein/lib/kruptein.js?");

/***/ }),

/***/ "./node_modules/query-string/index.js":
/*!********************************************!*\
  !*** ./node_modules/query-string/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst strictUriEncode = __webpack_require__(/*! strict-uri-encode */ \"./node_modules/strict-uri-encode/index.js\");\n\nconst decodeComponent = __webpack_require__(/*! decode-uri-component */ \"decode-uri-component\");\n\nconst splitOnFirst = __webpack_require__(/*! split-on-first */ \"./node_modules/split-on-first/index.js\");\n\nconst filterObject = __webpack_require__(/*! filter-obj */ \"./node_modules/filter-obj/index.js\");\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\nconst encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');\n\nfunction encoderForArrayFormat(options) {\n  switch (options.arrayFormat) {\n    case 'index':\n      return key => (result, value) => {\n        const index = result.length;\n\n        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n          return result;\n        }\n\n        if (value === null) {\n          return [...result, [encode(key, options), '[', index, ']'].join('')];\n        }\n\n        return [...result, [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')];\n      };\n\n    case 'bracket':\n      return key => (result, value) => {\n        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n          return result;\n        }\n\n        if (value === null) {\n          return [...result, [encode(key, options), '[]'].join('')];\n        }\n\n        return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n      };\n\n    case 'comma':\n    case 'separator':\n    case 'bracket-separator':\n      {\n        const keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';\n        return key => (result, value) => {\n          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n            return result;\n          } // Translate null to an empty string so that it doesn't serialize as 'null'\n\n\n          value = value === null ? '' : value;\n\n          if (result.length === 0) {\n            return [[encode(key, options), keyValueSep, encode(value, options)].join('')];\n          }\n\n          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n        };\n      }\n\n    default:\n      return key => (result, value) => {\n        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n          return result;\n        }\n\n        if (value === null) {\n          return [...result, encode(key, options)];\n        }\n\n        return [...result, [encode(key, options), '=', encode(value, options)].join('')];\n      };\n  }\n}\n\nfunction parserForArrayFormat(options) {\n  let result;\n\n  switch (options.arrayFormat) {\n    case 'index':\n      return (key, value, accumulator) => {\n        result = /\\[(\\d*)\\]$/.exec(key);\n        key = key.replace(/\\[\\d*\\]$/, '');\n\n        if (!result) {\n          accumulator[key] = value;\n          return;\n        }\n\n        if (accumulator[key] === undefined) {\n          accumulator[key] = {};\n        }\n\n        accumulator[key][result[1]] = value;\n      };\n\n    case 'bracket':\n      return (key, value, accumulator) => {\n        result = /(\\[\\])$/.exec(key);\n        key = key.replace(/\\[\\]$/, '');\n\n        if (!result) {\n          accumulator[key] = value;\n          return;\n        }\n\n        if (accumulator[key] === undefined) {\n          accumulator[key] = [value];\n          return;\n        }\n\n        accumulator[key] = [].concat(accumulator[key], value);\n      };\n\n    case 'comma':\n    case 'separator':\n      return (key, value, accumulator) => {\n        const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n        const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);\n        value = isEncodedArray ? decode(value, options) : value;\n        const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n        accumulator[key] = newValue;\n      };\n\n    case 'bracket-separator':\n      return (key, value, accumulator) => {\n        const isArray = /(\\[\\])$/.test(key);\n        key = key.replace(/\\[\\]$/, '');\n\n        if (!isArray) {\n          accumulator[key] = value ? decode(value, options) : value;\n          return;\n        }\n\n        const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(item => decode(item, options));\n\n        if (accumulator[key] === undefined) {\n          accumulator[key] = arrayValue;\n          return;\n        }\n\n        accumulator[key] = [].concat(accumulator[key], arrayValue);\n      };\n\n    default:\n      return (key, value, accumulator) => {\n        if (accumulator[key] === undefined) {\n          accumulator[key] = value;\n          return;\n        }\n\n        accumulator[key] = [].concat(accumulator[key], value);\n      };\n  }\n}\n\nfunction validateArrayFormatSeparator(value) {\n  if (typeof value !== 'string' || value.length !== 1) {\n    throw new TypeError('arrayFormatSeparator must be single character string');\n  }\n}\n\nfunction encode(value, options) {\n  if (options.encode) {\n    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n  }\n\n  return value;\n}\n\nfunction decode(value, options) {\n  if (options.decode) {\n    return decodeComponent(value);\n  }\n\n  return value;\n}\n\nfunction keysSorter(input) {\n  if (Array.isArray(input)) {\n    return input.sort();\n  }\n\n  if (typeof input === 'object') {\n    return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map(key => input[key]);\n  }\n\n  return input;\n}\n\nfunction removeHash(input) {\n  const hashStart = input.indexOf('#');\n\n  if (hashStart !== -1) {\n    input = input.slice(0, hashStart);\n  }\n\n  return input;\n}\n\nfunction getHash(url) {\n  let hash = '';\n  const hashStart = url.indexOf('#');\n\n  if (hashStart !== -1) {\n    hash = url.slice(hashStart);\n  }\n\n  return hash;\n}\n\nfunction extract(input) {\n  input = removeHash(input);\n  const queryStart = input.indexOf('?');\n\n  if (queryStart === -1) {\n    return '';\n  }\n\n  return input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n  if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {\n    value = Number(value);\n  } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n    value = value.toLowerCase() === 'true';\n  }\n\n  return value;\n}\n\nfunction parse(query, options) {\n  options = Object.assign({\n    decode: true,\n    sort: true,\n    arrayFormat: 'none',\n    arrayFormatSeparator: ',',\n    parseNumbers: false,\n    parseBooleans: false\n  }, options);\n  validateArrayFormatSeparator(options.arrayFormatSeparator);\n  const formatter = parserForArrayFormat(options); // Create an object with no prototype\n\n  const ret = Object.create(null);\n\n  if (typeof query !== 'string') {\n    return ret;\n  }\n\n  query = query.trim().replace(/^[?#&]/, '');\n\n  if (!query) {\n    return ret;\n  }\n\n  for (const param of query.split('&')) {\n    if (param === '') {\n      continue;\n    }\n\n    let [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '='); // Missing `=` should be `null`:\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\n    value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);\n    formatter(decode(key, options), value, ret);\n  }\n\n  for (const key of Object.keys(ret)) {\n    const value = ret[key];\n\n    if (typeof value === 'object' && value !== null) {\n      for (const k of Object.keys(value)) {\n        value[k] = parseValue(value[k], options);\n      }\n    } else {\n      ret[key] = parseValue(value, options);\n    }\n  }\n\n  if (options.sort === false) {\n    return ret;\n  }\n\n  return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n    const value = ret[key];\n\n    if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n      // Sort object keys, not values\n      result[key] = keysSorter(value);\n    } else {\n      result[key] = value;\n    }\n\n    return result;\n  }, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n  if (!object) {\n    return '';\n  }\n\n  options = Object.assign({\n    encode: true,\n    strict: true,\n    arrayFormat: 'none',\n    arrayFormatSeparator: ','\n  }, options);\n  validateArrayFormatSeparator(options.arrayFormatSeparator);\n\n  const shouldFilter = key => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';\n\n  const formatter = encoderForArrayFormat(options);\n  const objectCopy = {};\n\n  for (const key of Object.keys(object)) {\n    if (!shouldFilter(key)) {\n      objectCopy[key] = object[key];\n    }\n  }\n\n  const keys = Object.keys(objectCopy);\n\n  if (options.sort !== false) {\n    keys.sort(options.sort);\n  }\n\n  return keys.map(key => {\n    const value = object[key];\n\n    if (value === undefined) {\n      return '';\n    }\n\n    if (value === null) {\n      return encode(key, options);\n    }\n\n    if (Array.isArray(value)) {\n      if (value.length === 0 && options.arrayFormat === 'bracket-separator') {\n        return encode(key, options) + '[]';\n      }\n\n      return value.reduce(formatter(key), []).join('&');\n    }\n\n    return encode(key, options) + '=' + encode(value, options);\n  }).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (url, options) => {\n  options = Object.assign({\n    decode: true\n  }, options);\n  const [url_, hash] = splitOnFirst(url, '#');\n  return Object.assign({\n    url: url_.split('?')[0] || '',\n    query: parse(extract(url), options)\n  }, options && options.parseFragmentIdentifier && hash ? {\n    fragmentIdentifier: decode(hash, options)\n  } : {});\n};\n\nexports.stringifyUrl = (object, options) => {\n  options = Object.assign({\n    encode: true,\n    strict: true,\n    [encodeFragmentIdentifier]: true\n  }, options);\n  const url = removeHash(object.url).split('?')[0] || '';\n  const queryFromUrl = exports.extract(object.url);\n  const parsedQueryFromUrl = exports.parse(queryFromUrl, {\n    sort: false\n  });\n  const query = Object.assign(parsedQueryFromUrl, object.query);\n  let queryString = exports.stringify(query, options);\n\n  if (queryString) {\n    queryString = `?${queryString}`;\n  }\n\n  let hash = getHash(object.url);\n\n  if (object.fragmentIdentifier) {\n    hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;\n  }\n\n  return `${url}${queryString}${hash}`;\n};\n\nexports.pick = (input, filter, options) => {\n  options = Object.assign({\n    parseFragmentIdentifier: true,\n    [encodeFragmentIdentifier]: false\n  }, options);\n  const {\n    url,\n    query,\n    fragmentIdentifier\n  } = exports.parseUrl(input, options);\n  return exports.stringifyUrl({\n    url,\n    query: filterObject(query, filter),\n    fragmentIdentifier\n  }, options);\n};\n\nexports.exclude = (input, filter, options) => {\n  const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n  return exports.pick(input, exclusionFilter, options);\n};\n\n//# sourceURL=webpack:///./node_modules/query-string/index.js?");

/***/ }),

/***/ "./node_modules/random-bytes/index.js":
/*!********************************************!*\
  !*** ./node_modules/random-bytes/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * random-bytes\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n/**\n * Module variables.\n * @private\n */\n\n\nvar generateAttempts = crypto.randomBytes === crypto.pseudoRandomBytes ? 1 : 3;\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = randomBytes;\nmodule.exports.sync = randomBytesSync;\n/**\n * Generates strong pseudo-random bytes.\n *\n * @param {number} size\n * @param {function} [callback]\n * @return {Promise}\n * @public\n */\n\nfunction randomBytes(size, callback) {\n  // validate callback is a function, if provided\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('argument callback must be a function');\n  } // require the callback without promises\n\n\n  if (!callback && !global.Promise) {\n    throw new TypeError('argument callback is required');\n  }\n\n  if (callback) {\n    // classic callback style\n    return generateRandomBytes(size, generateAttempts, callback);\n  }\n\n  return new Promise(function executor(resolve, reject) {\n    generateRandomBytes(size, generateAttempts, function onRandomBytes(err, str) {\n      if (err) return reject(err);\n      resolve(str);\n    });\n  });\n}\n/**\n * Generates strong pseudo-random bytes sync.\n *\n * @param {number} size\n * @return {Buffer}\n * @public\n */\n\n\nfunction randomBytesSync(size) {\n  var err = null;\n\n  for (var i = 0; i < generateAttempts; i++) {\n    try {\n      return crypto.randomBytes(size);\n    } catch (e) {\n      err = e;\n    }\n  }\n\n  throw err;\n}\n/**\n * Generates strong pseudo-random bytes.\n *\n * @param {number} size\n * @param {number} attempts\n * @param {function} callback\n * @private\n */\n\n\nfunction generateRandomBytes(size, attempts, callback) {\n  crypto.randomBytes(size, function onRandomBytes(err, buf) {\n    if (!err) return callback(null, buf);\n    if (! --attempts) return callback(err);\n    setTimeout(generateRandomBytes.bind(null, size, attempts, callback), 10);\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/random-bytes/index.js?");

/***/ }),

/***/ "./node_modules/split-on-first/index.js":
/*!**********************************************!*\
  !*** ./node_modules/split-on-first/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = (string, separator) => {\n  if (!(typeof string === 'string' && typeof separator === 'string')) {\n    throw new TypeError('Expected the arguments to be of type `string`');\n  }\n\n  if (separator === '') {\n    return [string];\n  }\n\n  const separatorIndex = string.indexOf(separator);\n\n  if (separatorIndex === -1) {\n    return [string];\n  }\n\n  return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];\n};\n\n//# sourceURL=webpack:///./node_modules/split-on-first/index.js?");

/***/ }),

/***/ "./node_modules/strict-uri-encode/index.js":
/*!*************************************************!*\
  !*** ./node_modules/strict-uri-encode/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n\n//# sourceURL=webpack:///./node_modules/strict-uri-encode/index.js?");

/***/ }),

/***/ "./node_modules/uid-safe/index.js":
/*!****************************************!*\
  !*** ./node_modules/uid-safe/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * uid-safe\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar randomBytes = __webpack_require__(/*! random-bytes */ \"./node_modules/random-bytes/index.js\");\n/**\n * Module variables.\n * @private\n */\n\n\nvar EQUAL_END_REGEXP = /=+$/;\nvar PLUS_GLOBAL_REGEXP = /\\+/g;\nvar SLASH_GLOBAL_REGEXP = /\\//g;\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = uid;\nmodule.exports.sync = uidSync;\n/**\n * Create a unique ID.\n *\n * @param {number} length\n * @param {function} [callback]\n * @return {Promise}\n * @public\n */\n\nfunction uid(length, callback) {\n  // validate callback is a function, if provided\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('argument callback must be a function');\n  } // require the callback without promises\n\n\n  if (!callback && !global.Promise) {\n    throw new TypeError('argument callback is required');\n  }\n\n  if (callback) {\n    // classic callback style\n    return generateUid(length, callback);\n  }\n\n  return new Promise(function executor(resolve, reject) {\n    generateUid(length, function onUid(err, str) {\n      if (err) return reject(err);\n      resolve(str);\n    });\n  });\n}\n/**\n * Create a unique ID sync.\n *\n * @param {number} length\n * @return {string}\n * @public\n */\n\n\nfunction uidSync(length) {\n  return toString(randomBytes.sync(length));\n}\n/**\n * Generate a unique ID string.\n *\n * @param {number} length\n * @param {function} callback\n * @private\n */\n\n\nfunction generateUid(length, callback) {\n  randomBytes(length, function (err, buf) {\n    if (err) return callback(err);\n    callback(null, toString(buf));\n  });\n}\n/**\n * Change a Buffer into a string.\n *\n * @param {Buffer} buf\n * @return {string}\n * @private\n */\n\n\nfunction toString(buf) {\n  return buf.toString('base64').replace(EQUAL_END_REGEXP, '').replace(PLUS_GLOBAL_REGEXP, '-').replace(SLASH_GLOBAL_REGEXP, '_');\n}\n\n//# sourceURL=webpack:///./node_modules/uid-safe/index.js?");

/***/ }),

/***/ "./wizzi/factory.js":
/*!**************************!*\
  !*** ./wizzi/factory.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const path = __webpack_require__(/*! path */ \"path\");\n\nconst wizzi = __webpack_require__(/*! wizzi */ \"wizzi\");\n\nconst wizziRepo = __webpack_require__(/*! wizzi-repo */ \"wizzi-repo\");\n\nconst packiFilePrefix = 'json://';\nlet md;\nmodule.exports = md = {\n  packiFilesToJsonDocuments: function packiFilesToJsonDocuments(files) {\n    const jsonDocuments = [];\n    Object.keys(files).map(value => {\n      if (files[value].type === 'CODE') {\n        const filePath = md.ensurePackiFilePrefix(value);\n        jsonDocuments.push({\n          path: filePath,\n          content: files[value].contents\n        });\n      }\n    });\n    return jsonDocuments;\n  },\n  createFsJsonAndFactory: async function (files) {\n    const plugins = [];\n    const jsonDocuments = [];\n    Object.keys(files).map(value => {\n      if (files[value].type === 'CODE' && files[value].contents && files[value].contents.length > 0) {\n        const filePath = md.ensurePackiFilePrefix(value);\n        jsonDocuments.push({\n          path: filePath,\n          content: files[value].contents\n        });\n        const pluginList = pluginsFor(filePath);\n        pluginList.forEach(item => {\n          if (plugins.indexOf(item) < 0) {\n            plugins.push(item);\n          }\n        });\n      }\n    });\n    console.log('createFactory', plugins, 'jsonDocuments.length', jsonDocuments.length);\n    return new Promise((resolve, reject) => wizziRepo.JsonComponents.createFsJson(jsonDocuments, (err, fsJson) => {\n      if (err) {\n        return reject(err);\n      }\n\n      wizzi.jsonFactory({\n        fsJson,\n        plugins: {\n          items: ['wizzi-core', 'wizzi-js', 'wizzi-web'\n          /*\r\n          './wizzi-core/dist/index.js', \r\n          './wizzi-js/dist/index.js', \r\n          './wizzi-web/dist/index.js', \r\n          './wizzi-meta/dist/index.js'\r\n          */\n          ] // pluginsBaseFolder: 'C:/My/wizzi/stfnbssl/wizzi/packages'\n\n        }\n      }, function (err, wf) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve({\n          wf,\n          fsJson\n        });\n      });\n    }));\n  },\n  createFsJson: async function createFsJson(files) {\n    const jsonDocuments = [];\n    Object.keys(files).map(value => {\n      if (files[value].type === 'CODE') {\n        const filePath = md.ensurePackiFilePrefix(value);\n        jsonDocuments.push({\n          path: filePath,\n          content: files[value].contents\n        });\n      }\n    });\n    console.log('createFsJson', 'jsonDocuments.length', jsonDocuments.length);\n    return new Promise((resolve, reject) => wizziRepo.JsonComponents.createFsJson(jsonDocuments, (err, result) => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve(result);\n    }));\n  },\n  extractGeneratedFiles: async function extractGeneratedFiles(fsJson) {\n    const files = {};\n    return new Promise((resolve, reject) => fsJson.toFiles({\n      removeRoot: packiFilePrefix\n    }, (err, result) => {\n      if (err) {\n        reject(err);\n      }\n\n      result.forEach(value => {\n        if (value.relPath.endsWith('.ittf') == false) {\n          files[value.relPath] = {\n            type: 'CODE',\n            contents: value.content,\n            generated: true\n          };\n        }\n      });\n      resolve(files);\n    }));\n  },\n  ensurePackiFilePrefix: function (filePath) {\n    return filePath.startsWith(packiFilePrefix) ? filePath : packiFilePrefix + filePath;\n  }\n};\nconst schemaPluginMap = {\n  json: ['wizzi-core'],\n  text: ['wizzi-core'],\n  xml: ['wizzi-core'],\n  ittf: ['wizzi-core'],\n  wfjob: ['wizzi-core'],\n  wfschema: ['wizzi-core'],\n  js: ['wizzi-js'],\n  ts: ['wizzi-js'],\n  html: ['wizzi-web', 'wizzi-js', 'wizzi-core'],\n  css: ['wizzi-web'],\n  scss: ['wizzi-web'],\n  graphql: ['wizzi-web'],\n  vml: ['wizzi-web'],\n  vue: ['wizzi-web']\n};\n\nfunction pluginsFor(file) {\n  const nameParts = path.basename(file).split('.');\n\n  if (nameParts[nameParts.length - 1] === 'ittf') {\n    return schemaPluginMap[nameParts[nameParts.length - 2]] || [];\n  }\n\n  return [];\n}\n\n//# sourceURL=webpack:///./wizzi/factory.js?");

/***/ }),

/***/ "./wizzi/productions.js":
/*!******************************!*\
  !*** ./wizzi/productions.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const path = __webpack_require__(/*! path */ \"path\");\n\nconst factory = __webpack_require__(/*! ./factory */ \"./wizzi/factory.js\");\n\nconst {\n  createFsJsonAndFactory,\n  ensurePackiFilePrefix\n} = factory;\nconst myname = 'wizzi.productions';\nlet md;\nmodule.exports = md = {\n  generateArtifact: async function generateArtifact(filePath, packiFiles, context, options) {\n    return new Promise(async (resolve, reject) => {\n      const generator = options && options.generator ? options.generator : generatorFor(filePath);\n      console.log(myname + '.generateArtifact.using artifact generator', generator);\n\n      if (generator) {\n        let jsonwf = {};\n        let generationContext = {};\n        const ittfDocumentUri = ensurePackiFilePrefix(filePath);\n        /*\r\n        const wzCtxDocumentUri = Object.keys(packiFiles).find(k => \r\n            k.endsWith('wzctx.json.ittf')\r\n        );\r\n        */\n\n        try {\n          jsonwf = await createFsJsonAndFactory(packiFiles);\n          generationContext = Object.assign(context || {}, {// wzCtx: wzCtxDocumentUri ? await loadModelInternal(jsonwf.wf, ensurePackiFilePrefix(wzCtxDocumentUri), {}) : null\n          });\n          console.log(myname + '.generateArtifact.context', Object.keys(generationContext));\n          jsonwf.wf.loadModelAndGenerateArtifact(ittfDocumentUri, {\n            modelRequestContext: generationContext || {},\n            artifactRequestContext: generationContext || {}\n          }, generator, (err, result) => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve({\n              artifactContent: result,\n              sourcePath: filePath,\n              artifactGenerator: generator\n            });\n          });\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        reject('No artifact generator available for document ' + filePath);\n      }\n    });\n  },\n  transformModel: async function (filePath, packiFiles, context, options) {\n    return new Promise(async (resolve, reject) => {\n      const transformer = options && options.transformer ? options.transformer : transformerFor(filePath);\n      console.log('wizzi.productions.transformModel.using artifact transformer', transformer);\n\n      if (transformer) {\n        let jsonwf = {};\n        let transformationContext = {};\n        const ittfDocumentUri = ensurePackiFilePrefix(filePath);\n        const siteDocumentUri = Object.keys(packiFiles).find(k => k.endsWith('site.json.ittf'));\n\n        try {\n          jsonwf = await createFsJsonAndFactory(packiFiles);\n          transformationContext = {\n            site: siteDocumentUri ? await loadModelInternal(jsonwf.wf, ensurePackiFilePrefix(siteDocumentUri), {}) : null\n          };\n          console.log('wizzi.productions.transformModel.transformationContext', Object.keys(transformationContext));\n          jsonwf.wf.loadAndTransformModel(ittfDocumentUri, {\n            modelRequestContext: transformationContext\n          }, transformer, (err, result) => {\n            if (err) {\n              return reject(err);\n            } // console.log('Transformed result', result);\n\n\n            resolve({\n              transformResult: result,\n              sourcePath: filePath,\n              modelTransformer: transformer\n            });\n          });\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        reject('No model transformer available for document ' + filePath);\n      }\n    });\n  },\n  parseFilePath: function (filePath) {\n    const nameParts = path.basename(filePath).split('.');\n\n    if (nameParts[nameParts.length - 1] === 'ittf') {\n      return {\n        isIttfDocument: true,\n        schema: nameParts[nameParts.length - 2],\n        seedname: nameParts.slice(0, -2).join('.')\n      };\n    } else {\n      return {\n        isIttfDocument: false,\n        schema: nameParts[nameParts.length - 1],\n        seedname: nameParts.slice(0, -1).join('.')\n      };\n    }\n  }\n};\n\nasync function loadModelInternal(wf, filePath, context) {\n  return new Promise(async (resolve, reject) => {\n    const schemaName = schemaFromFilePath(filePath);\n\n    if (!schemaName) {\n      return reject('File is not a known ittf document: ' + filePath);\n    }\n\n    wf.loadModel(schemaName, filePath, {\n      mTreeBuildUpContext: context\n    }, (err, result) => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve(result);\n    });\n  });\n}\n\nconst extSchemaMap = {\n  '.js': 'js',\n  '.jsx': 'js',\n  '.ts': 'ts',\n  '.tsx': 'ts',\n  '.html': 'html',\n  '.css': 'css',\n  '.svg': 'svg',\n  '.md': 'md',\n  '.xml': 'xml',\n  '.json': 'json',\n  '.graphql': 'graphql'\n};\nconst schemaModuleMap = {\n  css: 'css/document',\n  graphql: 'graphql/document',\n  ittf: 'ittf/document',\n  js: 'js/module',\n  json: 'json/document',\n  html: 'html/document',\n  md: 'md/document',\n  scss: 'scss/document',\n  svg: 'svg/document',\n  text: 'text/document',\n  ts: 'ts/module',\n  vml: 'vml/document',\n  vue: 'vue/document',\n  xml: 'xml/document'\n};\n\nfunction generatorFor(filePath) {\n  const pf = md.parseFilePath(filePath);\n\n  if (pf.isIttfDocument) {\n    return schemaModuleMap[pf.schema];\n  }\n\n  return undefined;\n}\n\nconst schemaTransformerMap = {\n  meta: 'ittf/cheatsheet'\n};\n\nfunction transformerFor(filePath) {\n  const pf = md.parseFilePath(filePath);\n\n  if (pf.isIttfDocument) {\n    return schemaTransformerMap[pf.schema];\n  }\n\n  return undefined;\n}\n\nfunction schemaFromFilePath(filePath) {\n  const pf = md.parseFilePath(filePath);\n\n  if (pf.isIttfDocument) {\n    return pf.schema;\n  }\n\n  return undefined;\n}\n\n//# sourceURL=webpack:///./wizzi/productions.js?");

/***/ }),

/***/ "asn1.js":
/*!**************************!*\
  !*** external "asn1.js" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"asn1.js\");\n\n//# sourceURL=webpack:///external_%22asn1.js%22?");

/***/ }),

/***/ "console":
/*!**************************!*\
  !*** external "console" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"console\");\n\n//# sourceURL=webpack:///external_%22console%22?");

/***/ }),

/***/ "cookie":
/*!*************************!*\
  !*** external "cookie" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"cookie\");\n\n//# sourceURL=webpack:///external_%22cookie%22?");

/***/ }),

/***/ "cookie-signature":
/*!***********************************!*\
  !*** external "cookie-signature" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"cookie-signature\");\n\n//# sourceURL=webpack:///external_%22cookie-signature%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"debug\");\n\n//# sourceURL=webpack:///external_%22debug%22?");

/***/ }),

/***/ "decode-uri-component":
/*!***************************************!*\
  !*** external "decode-uri-component" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"decode-uri-component\");\n\n//# sourceURL=webpack:///external_%22decode-uri-component%22?");

/***/ }),

/***/ "depd":
/*!***********************!*\
  !*** external "depd" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"depd\");\n\n//# sourceURL=webpack:///external_%22depd%22?");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"dotenv\");\n\n//# sourceURL=webpack:///external_%22dotenv%22?");

/***/ }),

/***/ "envalid":
/*!**************************!*\
  !*** external "envalid" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"envalid\");\n\n//# sourceURL=webpack:///external_%22envalid%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"express\");\n\n//# sourceURL=webpack:///external_%22express%22?");

/***/ }),

/***/ "follow-redirects":
/*!***********************************!*\
  !*** external "follow-redirects" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"follow-redirects\");\n\n//# sourceURL=webpack:///external_%22follow-redirects%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack:///external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack:///external_%22https%22?");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mongodb\");\n\n//# sourceURL=webpack:///external_%22mongodb%22?");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mongoose\");\n\n//# sourceURL=webpack:///external_%22mongoose%22?");

/***/ }),

/***/ "node-cache":
/*!*****************************!*\
  !*** external "node-cache" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"node-cache\");\n\n//# sourceURL=webpack:///external_%22node-cache%22?");

/***/ }),

/***/ "on-headers":
/*!*****************************!*\
  !*** external "on-headers" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"on-headers\");\n\n//# sourceURL=webpack:///external_%22on-headers%22?");

/***/ }),

/***/ "parseurl":
/*!***************************!*\
  !*** external "parseurl" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"parseurl\");\n\n//# sourceURL=webpack:///external_%22parseurl%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "safe-buffer":
/*!******************************!*\
  !*** external "safe-buffer" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"safe-buffer\");\n\n//# sourceURL=webpack:///external_%22safe-buffer%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack:///external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ }),

/***/ "wizzi":
/*!************************!*\
  !*** external "wizzi" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"wizzi\");\n\n//# sourceURL=webpack:///external_%22wizzi%22?");

/***/ }),

/***/ "wizzi-repo":
/*!*****************************!*\
  !*** external "wizzi-repo" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"wizzi-repo\");\n\n//# sourceURL=webpack:///external_%22wizzi-repo%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=webpack:///external_%22zlib%22?");

/***/ })

/******/ });